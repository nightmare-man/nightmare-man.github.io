---
layout: post
title: 算法难点复习
subtitle: 算法难点复习
date: 2023-4-3
author: nightmare-man
tags: 数据结构与算法
---

# 0x00 kmp

​	字符串比较算法，核心思想，跳过重复比较，例子：

```c++
/*
->abababc  str
->ababc    pattern  
-> ababc
->  ababc

*/
```

在str[4]与pattern[4]时不同，暴力求解时，将str指针i+1，将pattern指针j置0，然后a与b比较，不同然后又将i+1,j置0得到结果，最终匹配。 时间复杂夫m*n

考虑优化

当在pattern[4]处发生不匹配时，我们直接将pattern串整体右移2，str i指针不变，patternj指针j=j-2,2是右移的位数。为什么能够直接右移2呢，因为已经匹配长度为4的字符串，前缀和尾缀的部分匹配值为2（前缀和尾缀的最大公共部分）,因此可以直接右移4-2个位置

因此kmp查找字串的框架为：

```c++
int solv(const string& str,const string& pattern){
    int i=0,j=0;
    for(;i<str.size()&&j<pattern.size();){
        if(str[i]==pattern[j]) {
            i++;j++;
        }else{
            if(j=0){
                i++;
                j++;
            }else{
                j=j-(j-1-match[j-1]);
            }
            
        }
    }
    if(j==pattern.size()) return i-pattern.size();
    else return -1;
}
```

怎么求match数组呢？用表达式递推，match[n]=match[n-1]+1 ,当pattern[n]==pattern[match[n-1]] 。这个表达式的原因n-1的头缀和尾缀 都有一个共同的新添加元素pattern[n]，因此头缀和尾缀的长度都加1，因此match[n]=match[n-1]+1。如果不等呢，那就要考虑缩短原来的头缀，且头缀的最后一个元素也要与pattern[n-1]相等，之前是pattern[match[n-1]-1],现在这个元素是pattern[ match[ match[n-1]-1]-1 ],pattern[n]比较的是pattern[match[ match[n-1]-1 ]],相等match[n]=match[match[n-1]-1]+1,那边界条件是什么呢？边界条件是如果不想等时，pattern[i] i是被比较的元素，已经为0时，说明已经不能再比较了，此时match[n]=0; kmp算法**时间复杂度m+n** 注意常数不是1

# 0x01 二叉树的非递归遍历

将递归函数转为非递归函数需要栈的支持。

考虑函数的实现，通过栈保存调用位置，因此我们也需要一个结构保存递归的时的位置。

```c++
void preorder_trans(Node* p){
    if(p){
        preorder_trans(p->l);
        visit(p);
        preorder_trans(p->r);
    }
}
```

```c++
struct node{
    int val;
    struct node* l;
    struct node* r;
    int step; 
    node():val{0},l{nullptr},r{nullptr},step{0}{};
};
void visit(node* p){
    cout<<p->val<<endl;
}
void trans(node* p){
    stack<node*> s{};
    s.push(p);
    while(!s.empty()){
       node* p=s.top();
       if(!p){
        s.pop();
        continue;
       }
       switch (p->step)
       {
       case 0:{
        s.push(p->l);
       }
        break;
        case 1:{
            visit(p);
        }
        break;
        case 2:{
            s.push(p->r);
        }
       break;
       default:
        s.pop();
        break;
       }
       p->step++;
    }
}
```

​	因为每一个节点作为参数产生一个函数调用栈，因此我们不妨在node中定义一个step表示阶段。用一个while循环当作cpu，当函数调用不空，也就是栈不空时，一直循环，每次对当前栈（top）进行一次处理，将其阶段+1；根据原来递归函数，可以在不同的阶段产生新的调用栈，下一次循环时就来到栈顶，而如果某个栈执行到了最后阶段，就pop掉该栈，即退出函数调用。

​	**空间复杂度O(n)时间复杂度O(n)**

# 0x02 树转二叉树、森林转二叉树

​	树转二叉树，对于其子节点，选一个（一般是第一个）作为其左孩子，其余子节点（兄弟节点），作为左孩子的右孩子，不断向右延申。然后对每一个子节点重复前面过程，伪代码如下：

```c++
//由于对一个节点的处理，会移动其原本子节点的位置，因此使用层序便来来处理最好，在处理节点时，能将其子节点先保存在队列里
void trans(Node* p){
    if(!p) return;
    queue q{};
    q->append(p);
    while(q.size()){
        p=q.dequeue();
        Node* l=nullptr;
        //i=0时是第一个选为左孩子不用改变位置
        for(int i=0;i<p->childsize();i++){
        	if(i==0) {
                p->l=p->child[0];
                l=p->l;
            }else{
                l->r=p->child[i];
                l=p->child[i];
            }
            q.append(p->child[i]);
        }
    }
}
```

​	而森林的转换则可以可以给所有僧侣加一个根节点，转换成二叉树后去掉根节点。

# 0x03 哈夫曼树与编码

​	哈夫曼树是带权路径和最短的树，应用于压缩算法，带权路径指，叶子节点的权值*根节点到叶子节点的路径长度（边数，在第二层则路径长1，依此类推）。而哈夫曼树的所有叶子节点的带权路径和最小。构造方法如下：

```c++
//1将n个节点作为n个仅含1个节点的二叉树,形成一个森林
//2从森林中移除根节点的值最小的两个二叉树，作为左子树右子树，添加一个根节点，为左右子树的根的和，放回森林
//3重复2，直到森林中仅有一棵树，即为哈夫曼树
```

​	哈夫曼树用于前缀编码，即任何一个编码是其他编码的前缀。对于文本压缩，假设仅有a-z26个字母，则根据字母出现的次数作为权重，形成哈夫曼树，从根开始，左边代表0，右边代表1，访问一个叶节点产生的边序列，即为对应字符的哈夫曼编码。

​	每次都需要找到最小的两个节点，更新后插入最大节点，适合用堆，此时时间复杂度O(nlog) 空间复杂度O(n)

# 0x04 并查集

​	并查集，集合中选一个元素作为根节点，其余元素作为子节点，记录每一个元素的根节点，根节点记录该集合元素个数。并操作，一个集合的根节点的根节点设置为另一个集合的根节点。  查操作（查询元素属于哪个集合），不断访问其根节点，直到无根可循。

# 0x05 图概念及特征

​	**完全图**，有向图中指任意两个顶点存在两个方向边，无向图任意两点存在边，故边数前者为n\*(n-1) 后者为n\*(n-1)/2 每个点有n-1条边，n个点，但是被计算了两次。

​	**连通图**，指无向图中任意两点存在路径，**连通分量**，非连通的无向图中的极大连通子图（包含最多都互相连通的顶点和边）。 n个顶点的无向图，不连通同时最大边的数量：(n-)\*(n-2)/2 ，即除一个顶点外，其余完全图。

​	**强连通**，指有向图

​	**生成树**：指完全图中包含全部顶点的**极小连同分量**（包含最少的边，因为顶点要求了为全部顶点）

​	**度**，指依附顶点的边数，无向图度=2\*e,因为一条边被算两次

# 0x06 图的有关算法

​	**遍历**  DFS，访问起始顶点，依次访问与之相邻的顶点，直到无相邻顶点可访问，在访问相邻顶点时，递归的重复上述过程：

```c++
void DFS(Node* p){
    visit(p);
    for(auto child: p->child){
        if(!child->visit)
        	DFS(child);
    }
}
```

​	BFS 类似于树的层序遍历，1将起始顶点加入队列，2出队列一个元素，访问 3将该元素的相邻节点加入队列，重复23直到队列空

```c++
void BFS(Node* p){
    queue q{};
    q.push(p);
    while(q.size()){
        p=q.front();
        q.pop();
        visit(p);
        for(auto child:p->child){
            if(!child->visit)
            	q.push(child);
        }
    }
}
```

​	DFS BFS 的复杂度分析，首先都遍历了所有顶点，其次，访问了顶点的所有边。因此如果使用邻接矩阵，那么访问顶点所有边为n^2,而遍历顶点为n，因此**时间复杂度O(n^2)**,如果用邻接表则访问所有边为E,因此**为O(n+e)** 对于稀疏图，适合用邻接表，对于稠密图，适合邻接矩阵。

​	**判断图是否连通**，任意选一个顶点，进行遍历，如果遍历后仍然有点未访问，则不连通。

​	**最小生成树**：即极小连同分量，且边的权之和最小。**原则是贪心**算法：不断选择最小且不形成回路的边。最小生成树不止一棵，但权值和一样。

​	两种方法，prim算法，保证不形成回路的方法就是**不断往已经形成的连通分量里 新增边最小的顶点。**从始至终都是一个连同分量，直到扩展到极小连通分量包含所有顶点。

​	kruskal：保证不形成回路的方法，不断将**属于两个不同连同分量**，**且距离最小的顶点**对连接起来。

​	**最短路径**

​	**dijinstra**： 贪心算法，有两个列表，一个记录已经加入最短路径的顶点，另一个记录未加入的。初始仅有起点加入。distance[n]负责记录点到起点的距离，初始时起点为0，不相连的为+∞。 path[n]记录最短路径时，上一个节点

​	每次从未加入的列表中选一个distanc最小的点加入，并更新与之相连距离。不断重复直到所有点加入。

```c++
void dijinstra(Node* start,vector<int>& distance,vector<int>& path){
    init(distance);
    init(path);
    vector<int> exclude{};
    init(exclude);
    while(exclude.size()){
        Node* tmp=pop_min_distance(exclude);
        for(auto close:tmp){
            if(distance[tmp]+e(tmp,close)<distance[close]){
                distance[close]=\
                distance[tmp]+e(tmp,close);
                path[close]=tmp;
            } 
            
        }
    }
}
```

使用邻接矩阵时，n个顶点都要访问，每次找最小的顶点需要遍历n个，找所有相邻的边需要也遍历n个，因此**时间复杂夫为O(n^2)**。使用邻接表也一样，因为总需要找最小顶点。

**froyd**,动态规划的方法，dis\[i\]\[j\]=dis\[i\]\[j\]经过0和不经过0的路线中最小的，同理，也是经过1和不经过1中最小的，以此类推，最终为O(n^3)。具体这里不分析，见算法动态规划。