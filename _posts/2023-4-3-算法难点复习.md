---
layout: post
title: 算法难点复习
subtitle: 算法难点复习
date: 2023-4-3
author: nightmare-man
tags: 数据结构与算法
---

# 0x00 kmp

​	字符串比较算法，核心思想，跳过重复比较，例子：

```c++
/*
->abababc  str
->ababc    pattern  
-> ababc
->  ababc

*/
```

在str[4]与pattern[4]时不同，暴力求解时，将str指针i+1，将pattern指针j置0，然后a与b比较，不同然后又将i+1,j置0得到结果，最终匹配。 时间复杂夫m*n

考虑优化

当在pattern[4]处发生不匹配时，我们直接将pattern串整体右移2，str i指针不变，patternj指针j=j-2,2是右移的位数。为什么能够直接右移2呢，因为已经匹配长度为4的字符串，前缀和尾缀的部分匹配值为2（前缀和尾缀的最大公共部分）,因此可以直接右移4-2个位置

因此kmp查找字串的框架为：

```c++
int solv(const string& str,const string& pattern){
    int i=0,j=0;
    for(;i<str.size()&&j<pattern.size();){
        if(str[i]==pattern[j]) {
            i++;j++;
        }else{
            if(j=0){
                i++;
                j++;
            }else{
                j=j-(j-1-match[j-1]);
            }
            
        }
    }
    if(j==pattern.size()) return i-pattern.size();
    else return -1;
}
```

怎么求match数组呢？用表达式递推，match[n]=match[n-1]+1 ,当pattern[n]==pattern[match[n-1]] 。这个表达式的原因n-1的头缀和尾缀 都有一个共同的新添加元素pattern[n]，因此头缀和尾缀的长度都加1，因此match[n]=match[n-1]+1。如果不等呢，那就要考虑缩短原来的头缀，且头缀的最后一个元素也要与pattern[n-1]相等，之前是pattern[match[n-1]-1],现在这个元素是pattern[ match[ match[n-1]-1]-1 ],pattern[n]比较的是pattern[match[ match[n-1]-1 ]],相等match[n]=match[match[n-1]-1]+1,那边界条件是什么呢？边界条件是如果不想等时，pattern[i] i是被比较的元素，已经为0时，说明已经不能再比较了，此时match[n]=0;

# 0x01 二叉树的非递归遍历

将递归函数转为非递归函数需要栈的支持。

考虑函数的实现，通过栈保存调用位置，因此我们也需要一个结构保存递归的时的位置。

```c++
void preorder_trans(Node* p){
    if(p){
        preorder_trans(p->l);
        visit(p);
        preorder_trans(p->r);
    }
}
```

```c++
struct node{
    int val;
    struct node* l;
    struct node* r;
    int step; 
    node():val{0},l{nullptr},r{nullptr},step{0}{};
};
void visit(node* p){
    cout<<p->val<<endl;
}
void trans(node* p){
    stack<node*> s{};
    s.push(p);
    while(!s.empty()){
       node* p=s.top();
       if(!p){
        s.pop();
        continue;
       }
       switch (p->step)
       {
       case 0:{
        s.push(p->l);
       }
        break;
        case 1:{
            visit(p);
        }
        break;
        case 2:{
            s.push(p->r);
        }
       break;
       default:
        s.pop();
        break;
       }
       p->step++;
    }
}
```

​	因为每一个节点作为参数产生一个函数调用栈，因此我们不妨在node中定义一个step表示阶段。用一个while循环当作cpu，当函数调用不空，也就是栈不空时，一直循环，每次对当前栈（top）进行一次处理，将其阶段+1；根据原来递归函数，可以在不同的阶段产生新的调用栈，下一次循环时就来到栈顶，而如果某个栈执行到了最后阶段，就pop掉该栈，即退出函数调用。