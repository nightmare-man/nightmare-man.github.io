---
layout: post
title: 从实模式到保护模式笔记11任务切换
subtitle: 从实模式到保护模式笔记11任务切换
date: 2020-07-16
author: nightmare-man
tags: x86汇编
---
# 从实模式到保护模式笔记笔记12分页机制和动态页面分配

### 0x00 代码

​	到了本章的内容比较复杂，要结合代码来看书，因此先把代码手打一遍：

​	以下是内核主体代码：

```nasm
;以下是常量定义
core_code_seg_sel	equ	0x38;内核代码段选择子
core_data_seg_sel	equ	0x30;内核数据段
sys_routine_seg_sel	equ	0x28;系统公共例程
video_ram_seg_sel	equ	0x20;0xb8000 显存
core_stack_seg_sel	equ	0x18;内核堆栈
mem_0_4_gb_seg_sel	equ	0x08;整个0-4GB内存的段

;=========================================================
;以下是header段，用于加载内核主体
SECTION header vstart=0
core_length	dd	core_end
sys_routine_seg	dd section.sys_routine_start
core_data_seg	dd	section.core_data_start
core_code_seg	dd	section.core_code_start
core_entry	dd start
dw	core_code_seg_sel

[bits 32]
;=========================================================
;以下是系统公共例程段
;---------------------------------------------------------
;字符串显示，以0结尾
;输入 ds:ebx 串地址
put_string:
push ecx
.getc:
mov cl,[ebx]
or cl,cl
jz .exit
call put_char
inc ebx
jmp .getc
.exit:
pop ecx
retf;段间返回

;---------------------------------------------------------
;字符显示
;输入 cl 字符ascii
put_char:
pushad

;以下取当前光标位置
mov dx,0x3d4
mov al,0x0e
out dx,al
inc dx
in al,dx
mov ah,al;光标高8位

dec dx;0x3d4
mov al,0x0f
out dx,al
inc dx
in al,dx
mov bx,ax;bx保存着光标位置

cmp cl,0x0d;\r\n 先检测回车
jnz .put_0a;如果不是回车 看看是不是换行
mov ax,bx
mov bl,80
div bl
mul bl
mov bx,ax
jmp .set_cursor;设置光标

.put_0a:
cmp cl,0x0a
jnz .put_other;其他字符正常输出
add bx,80
jmp .roll_screen;检查是不是要滚屏

.put_other:
push es
mov eax,video_ram_seg_sel
mov es,eax
shl bx,1
mov [es:bx],cl
pop es
;推进光标
shr bx,1
inc bx

.roll_screen:
cmp bx,2000
jl .set_cursor

push ds
push es
mov eax,video_ram_seg_sel
mov ds,eax
mov es,eax
cld
mov esi,0xa0
mov edi,0x00
mov ecx,1920
rep movsw
mov bx,3840
mov ecx,80
.cls:
mov word[es:bx],0x0720;清除最后一行
add bx,2
loop .cls

pop es
pop ds
mov bx,1920;光标回到最后一行开头
.set_cursor:
mov dx,0x3d4
mov al,0x0e
out dx,al
inc dx
mov al,bh
out dx,al
dec dx
mov al,0x0f
out dx,al
inc dx
mov al,bl
out dx,al

popad
ret

;---------------------------------------------------------
;读硬盘
;输入 eax 逻辑扇区号 ds:ebx 读至此地址 
;返回 ebx=ebx+512
read_hard_disk_0:
push eax
push ecx
push edx

push eax
mov dx,0x1f2
mov al,1
out dx,al;读取的扇区数

inc dx
pop eax
out dx,al;写入eax低8位

inc dx
mov cl,8
shr eax,cl
out dx,al;写入15-8位

inc dx
shr eax,cl
out dx,al;写入23-16位

inc dx
shr eax,cl
or al,0xe0
out dx,al;写入27-24

inc dx
mov al,0x20;读命令
out dx,al

.waits:
in al,dx
and al,0x88
cmp al,0x88
jnz .waits;等待硬盘准备好数据

mov ecx,256
mov dx,0x1f0;从此处读
.readw:
in ax,dx
mov [ebx],ax
add ebx,2
loop .readw

pop edx
pop ecx
pop eax
retf;段间返回

;---------------------------------------------------------
;在GDT内安装一个新描述符
;输入 edx:eax 描述符64位 
;返回 cx 描述符选择子
set_up_gdt_descriptor:
push eax
push ebx
push edx
push ds
push es

mov ebx,core_data_seg_sel
mov ds,ebx

sgdt [pgdt];讲GDTR内6字节写入指定内存
mov ebx,mem_0_4_gb_seg_sel
mov es,ebx

movzx ebx,word [pgdt];原gdt界限
inc bx;原gdt长度
add ebx,[pgdt+2];新描述符线性地址

mov [es:ebx],eax
mov [es:ebx+4],edx

add word [pgdt],8;增加长度

lgdt [pgdt];更改GDTR

mov ax,[pgdt];界限
xor dx,dx
mov bx,8
div bx
mov cx,ax;商 新的界限/8的商就是其索引号
shl cx,3;ti rpl占最右三位

pop es
pop ds

pop edx
pop ebx
pop eax
retf

;---------------------------------------------------------
;新建一个段描述符表
;输入 eax 线性及地址 ebx 段界限 ecx 属性（无关位0）
;返回 edx:eax描述符
make_seg_descriptor:
mov edx,eax
shl eax,16
or ax,bx;or后即得描述符低32位

and edx,0xffff0000;线性基地址高16位
rol edx,8;循环左移 recycle of left
bswap edx;交换31-24和0-7 交换23-16和15-8

xor bx,bx
or edx,ebx;将段界限16-19位装配
or edx,ecx;装配属性
retf

;---------------------------------------------------------
;构造门描述符（调用门）
;输入 eax 目标代码段内偏移地址
;bx 目标代码所在段的选择子
;cx 门描述符属性
;返回 edx:eax 完整描述符
make_gate_descriptor:
push ebx
push ecx

mov edx,eax
and edx,0xffff0000;得到偏移地址高16位
or dx,cx;将属性装配到edx

and eax,0x0000ffff;得到偏移地址低16位
shl ebx,16
or eax,ebx
pop ecx
pop ebx
retf

;---------------------------------------------------------
;分配一个4KB的物理页
;输入无
;返回 eax 页的物理地址
allocate_a_4k_page:
push ebx
push ecx
push edx
push ds

mov eax,core_data_seg_sel
mov ds,eax
xor eax,eax
.b1:
bts [page_bit_map],eax;从页映位串里找到第一个0，也就是对应第一个没有
jnc .b2               ;被占用的物理页
inc eax
cmp eax,page_map_len*8
jl .b1

mov ebx,message_3
call sys_routine_seg_sel:put_string
hlt;如果超过了指定大小还没找到，就停机
.b2:
shl eax,12;*4096 4kb一个页面，物理地址
pop ds
pop edx
pop ecx
pop ebx
ret

;---------------------------------------------------------
;分配一个线性地址页，安装在当前活动的层级分页结构中
;输入 ebx 页的线性地址
push eax
push ebx
push esi
push ds

mov eax,mem_0_4_gb_seg_sel
mov ds,eax

;检查该线性地址所对应的页表是否存在
mov esi,ebx
and esi,0xffc00000;最高10位 页目录 偏移
shr esi,20  ;右22位（把最高10放到左边） 左移2位*4 拿到在页目录的偏移地址
or esi,0xfffff000;加上页目录的线性地址，即拿到对应页目录对应项的线性地址

test dword [esi],0x00000001 ;检查P位，该线性地址是否存在对应的页面
jnz .b1;如果该线性地址存在对应页表，就直接往页表对应页分配一个物理地址

;否则就要先创建页表(页表大小为4KB，也要分配一个物理页)
call allocate_a_4k_page
or eax,0x00000007
mov [esi],eax;在页目录登记该页表（的物理地址）

.b1:
;至此 开始访问该线性地址在页表中的对应页，给其填上分配的物理地址
mov esi,ebx
shr esi,10;右移10位
and esi,0x003ff000;将原来的高10位取出，作为新的中10位
or esi,0xffc00000;新的高10位全1 ，也就是页目录的最后一项
 
and ebx,0x003ff000;原来的中10位取出
shr ebx,10 ;实际是右移12位 再*4 原来的中10位作为新的低12位偏移
or esi,ebx
call allocate_a_4k_page
or eax,0x00000007
mov [esi],eax

pop ds
pop esi
pop ebx
pop eax
retf

;这个例程要干嘛？要给esi（ebx）对应的线性地址分配一个物理页
;要怎么操作？给该线性地址对应页表的对应项填上分配好的物理页的地址
;关键是什么？如何访问前述的对应表的对应项的物理地址，该物理地址对应
;的线性地址是？

;给定线性地址，如何转换成物理地址？
;cr3里存着页目录的物理地址
;用给定的线性地址的高10位，作为索引，从页目录中读取对应的页表项的物理地址，访问该页表
;用给定的线性地址的中10位，作为索引，从对应页表的读取对应的页的物理地址
;用给定的线性地址的低12位，作为偏移地址，加上对应页的物理地址，即得到物理地址。

;页表的大小也是4096KB（1024项*4）,也可以看做一个页。那么我们要修改页表中某一项的值，其可以看做访问页内偏移地址为esi的中10位*4，所以我们要构造的线性地址的低12位是 esi的中10位*4。
;该页表作为页时，它所在的页表实际上是原来的页目录，所以要构造的线性地址的中10位，是esi的高10位。
;而该页表作为页时，其要构造的线性地址的高10位，为全1，对应的偏移是0xffc。因为0xffc在页目录中对应的页表项 是页目录自己。

;---------------------------------------------------------
;创建新页目录，并复制当前页目录内容
;输入 无
;输出 eax 新页目录的物理地址
create_copy_cur_pdir:
push ds
push es
push esi
push edi
push ebx
push ecx

mov ebx,mem_0_4_gb_seg_sel
mov ds,ebx
mov es,ebx

call allocate_a_4k_page ;分配一个物理页 用作目录页
mov ebx,eax
or ebx,0x00000007
mov [0xfffffff8],ebx

mov esi,0xfffff000;esi 当前页目录的线性地址
mov edi,0xffffe000;edi 新目录的线性地址
mov ecx,1024
cld
repe movsd

pop ecx
pop ebx
pop edi
pop esi
pop es
pop ds
retf

;---------------------------------------------------------
;终止当前任务 执行此例程时，仍处在任务的全局空间中，任务还没终止，执行完
;后才终止
;输入 无 输出 无
terminate_current_task:
mov eax,core_data_seg_sel
mov ds,eax
pushfd
pop edx
test dx,0100_0000_0000_0000B
jnz .b1
jmp far [program_man_tss];如果是jmp切换的任务就直接切回prgman
retf;万一又被重新执行了，会回到这里，所以retf回到任务局部空间
.b1:
iretd
retf

sys_routine_end:
;=========================================================
;系统核心数据段
SECTION core_data vstart=0
pgdt dw 0
dd 0;设置和修改GDTR

;以下为物理页映射位串，共512个二进制位，第N位对应第N个页，
;位为1表明该页面已经被占用，0表面空闲。
;512位对应512页，对应2MB内存，低1MB默认被系统占用，所以0xff
;而0x55是作者为了展示页面的占用不必一定连续
page_bit_map db  0xff,0xff,0xff,0xff,0xff,0x55,0x55,0xff
db  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
db  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
db  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
db  0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55
db  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
 
page_map_len equ $-page_bit_map

salt:
salt_1 db '@PrintString'
times 256-($-salt_1) db 0;256字节填充满
dd put_string
dw sys_routine_seg_sel

salt_2 db '@ReadDiskData'
times 256-($-salt_2) db 0;256字节填充满
dd read_hard_disk_0
dw sys_routine_seg_sel

salt_3 db '@TerminateProgram'
times 256-($-salt_3) db 0;256字节填充满
dd terminate_current_task
dw sys_routine_seg_sel

salt_item_len equ $-salt_3
salt_items equ ($-salt)/salt_item_len
message_0 db 'Working in system core,protect mode.'
dd 0x0d,0x0a,0
message_1 db 'Paging is enabled.System core is mapped to'
dd 'address 0x800000000.',0x0d,0x0a,0
message_2 db 0x0d,0x0a
dd 'System wide CALL-GATE mounted.',0x0d,0x0a,0
message_3 db '****No more pages****',0
message_4 db 0x0d,0x0a,'Task switching...',0x0d,0x0a,0
message_5 db 0x0d,0x0a,'Processor Halt.',0

core_buf times 512 db 0
cpu_brnd0 db 0x0d,0x0a,'  ',0
cpu_brnd times 52 db 0
cpu_brnd1 db 0x0d,0x0a,0

;任务控制块链
tcb_chain dd 0
;内核信息
core_next_laddr dd 0x80100000;内核中下一个可分配的线性地址
;（前1MB系统用了所以从0x80100000开始）
program_man_tss dd 0;内核的任务管理器tss偏移和选择子
dw 0

core_data_end:

;=========================================================
;内核代码段
SECTION core_code vstart=0
;---------------------------------------------------------
;在ldt里安装一个新的描述符
;输入 edx:eax 描述符 ebx tcb基地址
;输出 cx 描述符选择子
fill_descriptor_in_ldt:
push eax
push edx
push edi
push ds

mov ecx,mem_0_4_gb_seg_sel
mov ds,ecx

mov edi,[ebx+0x0c];获得LDT基地址
xor ecx,ecx
mov cx,[ebx+0x0a];获得LDT界限
inc cx;LDT大小

mov [edi+ecx+0x00],eax
mov [edi+ecx+0x04],edx ;安装新描述符

add cx,8
dec cx;新界限

mov [ebx+0x0a],cx
mov ax,cx
xor dx,dx
mov cx,8
div cx

mov cx,ax;商为选择子索引号
shl cx,3
or cx,0000_0000_0000_0100B;修改rpl3

pop ds
pop edi
pop edx
pop eax
ret;段内返回

;---------------------------------------------------------
;加载并重定向用户程序
;输入 push 逻辑扇区号 push tcb基地址
;输出 无
load_relocate_program:
pushad
push ds
push es
mov ebp,esp
mov ecx,mem_0_4_gb_seg_sel
mov es,ecx

;清空当前页目录的前半部分（对应低2GB的局部地址空间）
mov ebx,0xfffff000
xor esi,esi
.b1:
mov dword [es:ebx+esi*4],0x00000000
inc esi
cmp esi,512
jl .b1

;以下开始分配内存并加载用户程序
mov eax,core_data_seg_sel
mov ds,eax

mov eax,[ebp+12*4];取出扇区号
mov ebx,core_buf
call sys_routine_seg_sel:read_hard_disk_0

;以下获取程序大小
mov eax,[core_buf];程序大小
mov ebx,eax
and ebx,0xfffff000
add ebx,0x1000;4KB对齐，而不是512对齐了
test eax,0x00000fff
cmovnz eax,ebx;如果eax不是4KB对齐，那么就用对齐的EBX

mov ecx,eax
shr ecx,12;占用的总页数
mov eax,mem_0_4_gb_seg_sel
mov ds,eax

mov eax,[ebp+12*4]
mov esi,[ebp+11*4];tcb基地址
.b2:
mov ebx,[es:esi+0x06];
add dword [es:esi+0x06],0x1000
call sys_routine_seg_sel:alloc_inst_a_page
push ecx
mov ecx,8
.b3:
call sys_routine_seg_sel:read_hard_disk_0
inc eax
loop .b3

pop ecx
loop .b2
;在内核地址空间内创建用户任务的TSS
mov eax,core_data_seg_sel
mov ds,eax

mov ebx,[core_next_laddr]
call sys_routine_seg_sel:alloc_inst_a_page
add dword [core_next_laddr],4096

mov [es:esi+0x14],ebx;tss 基地址
mov word [es:esi+0x12],103;界限

;用户任务的局部地址空间创建LDT
mov ebx,[es:esi+0x06]
add dowrd [es:esi+0x06],0x1000
call sys_routine_seg_sel:alloc_inst_a_page
mov [es:esi+0x0c],ebx

;建立程序代码段描述符
mov eax,0x00000000
mov ebx,0x000fffff
mov ecx,0x00c0f800;4KB粒度 代码段
call sys_routine_seg_sel:make_seg_descriptor
mov ebx,esi
call fill_descriptor_in_ldt
or cx,0000_0000_0000_0011B;rpl置3

mov ebx,[es:esi+0x14];获取TSS线性基地址
mov [es:ebx+76],cx;填写TSSS的CS域

;建立程序数据段描述符
mov eax,0x00000000
mov ebx,0x000fffff
mov ecx,0x00c0f200;4KB粒度数据段
call sys_routine_seg_sel:make_seg_descriptor
mov ebx,esi
call fill_descriptor_in_ldt
or cx,0000_0000_0000_0011B;设置RPL

mov ebx,[es:esi+0x14];TSS线性基地址
mov [es:ebx+84],cx;填写TSS的ds域
mov [es:ebx+72],cx;es
mov [es:ebx+88],cx;fs
mov [es:ebx+92],cx;gs

;将数据段作为用户任务的3特权级固有堆栈
mov ebx,[es:esi+0x06];从tcb中获取可分配的线性地址
add dword [es:esi+0x06],0x1000;写入新的
call sys_routine_seg_sel:alloc_inst_a_page;给该地址分配页

mov ebx,[es:esi+0x14];从tcb获取TSS基地址
mov [es:ebx+80],cx;填写ss
mov edx,[es:esi+0x06];堆栈上界
mov [es:ebx+56],edx;填写esp

;在用户任务的局部地址空间创建额外0特权级堆栈
mov ebx,[es:esi+0x06]
add dword [es:esi+0x06],0x1000
call sys_routine_seg_sel:alloc_inst_a_page

mov eax,0x00000000
mov ebx,0x000fffff;实际上大小为4KB
mov ecx,0x00c09200;4KB粒度的堆栈描述符
call sys_routine_seg_sel:make_seg_descriptor
mov ebx,esi
call fill_descriptor_in_ldt
or cx,0000_0000_0000_0000B;RPL0

mov ebx,[es:esi+0x14]
mov [es:ebx+8],cx;填写TSS的SS0域
mov edx,[es:esi+0x06];堆栈上界限
mov [es:ebx+4],edx;tss esp0

;在用户任务的局部地址空间内创建1特权级堆栈
mov ebx,[es:esi+0x06]              ;从TCB中取得可用的线性地址
add dword [es:esi+0x06],0x1000
call sys_routine_seg_sel:alloc_inst_a_page

mov eax,0x00000000
mov ebx,0x000fffff
mov ecx,0x00c0b200                 ;4KB粒度的堆栈段描述符，特权级1
call sys_routine_seg_sel:make_seg_descriptor
mov ebx,esi                        ;TCB的基地址
call fill_descriptor_in_ldt
or cx,0000_0000_0000_0001B         ;设置选择子的特权级为1

mov ebx,[es:esi+0x14]              ;从TCB中获取TSS的线性地址
mov [es:ebx+16],cx                 ;填写TSS的SS1域
mov edx,[es:esi+0x06]              ;堆栈的高端线性地址
mov [es:ebx+12],edx                ;填写TSS的ESP1域 

;在用户任务的局部地址空间内创建2特权级堆栈
mov ebx,[es:esi+0x06]              ;从TCB中取得可用的线性地址
add dword [es:esi+0x06],0x1000
call sys_routine_seg_sel:alloc_inst_a_page

mov eax,0x00000000
mov ebx,0x000fffff
mov ecx,0x00c0d200                 ;4KB粒度的堆栈段描述符，特权级2
call sys_routine_seg_sel:make_seg_descriptor
mov ebx,esi                        ;TCB的基地址
call fill_descriptor_in_ldt
or cx,0000_0000_0000_0010B         ;设置选择子的特权级为2

mov ebx,[es:esi+0x14]              ;从TCB中获取TSS的线性地址
mov [es:ebx+24],cx                 ;填写TSS的SS2域
mov edx,[es:esi+0x06]              ;堆栈的高端线性地址
mov [es:ebx+20],edx                ;填写TSS的ESP2域 


;重定位salt
mov eax,mem_0_4_gb_seg_sel
mov es,eax

mov eax,core_data_seg_sel
mov ds,eax
cld
mov ecx,[es:0x0c];u_salt条目数
mov edi,[es:0x08];u_salt在任务4GB空间的偏移地址
.b4:
push ecx
push edi

mov ecx,salt_items
mov esi,salt
.b5:
push edi
push esi
push ecx

mov ecx,64
repe cmpsd;比较符号名
jnz .b6
mov eax,[esi];如果匹配，esi刚好移动到对应的偏移地址处
mov [es:edi-256],eax
mov ax,[esi+4]
or ax,0000_0000_0000_0011B ;以用户程序自己的特权级调用

mov [es:edi-252],ax
.b6:
pop ecx
pop esi
add esi,salt_item_len
pop edi
loop .b5;内循环，下一个c_salt项继续比较

pop edi
add edi,256
pop ecx
loop .b4;外循环，下一个u_salt项比较

;在GDT中登记LDT描述符
mov esi,[ebp+11*4]
mov eax,[es:esi+0x0c];LDT起始线性地址
movzx ebx,word[es:esi+0x0a];LDT界限
mov ecx,0x00408200;LDT描述符，特权级0
call sys_routine_seg_sel:make_seg_descriptor
call sys_routine_seg_sel:set_up_gdt_dsecriptor
mov [es:esi+0x10],cx;将选择子登记到TCB中

mov ebx,[es:esi+0x14];从TCB中获取TSS线性基地址
mov [es:ebx+96],cx;填写TSS的LDT域

mov word [es:ebx+0],0;上一级域为0

mov dx,[es:esi+0x12];TSS段界限
mov [es:ebx+102],cx;填写TSS的I/O位图偏移域，暂时填段界限就行

mov word [es:ebx+100],0;T=0,不开启软件调试

mov eax,[es:0x04];从任务的4GB地址空间的0x04偏移获得入口地址
mov [es:ebx+32],eax;填写TSS的EIP

pushfd
pop edx
mov [es:ebx+36],edx;填写EFLAGS
;在GDT中登记TSS描述符
mov eax,[es:esi+0x14];TSS起始线性地址
movzx ebx,word [es:esi+0x12];段界限，mov with zero extension
mov ecx,0x00408900;TSS描述符
call sys_routine_seg_sel:make_seg_descriptor
call sys_routine_seg_sel:set_up_gdt_descriptor
mov [es:esi+0x18],cx;登记TSS选择子到TCB

;创建用户任务的页目录
;//未完 待续
```





