---
layout: post
title: 从实模式到保护模式笔记笔记12分页机制和动态页面分配
subtitle: 从实模式到保护模式笔记笔记12分页机制和动态页面分配
date: 2020-07-19
author: nightmare-man
tags: x86汇编
---
# 从实模式到保护模式笔记笔记12分页机制和动态页面分配

### 0x00 代码

​	本章代码比较复杂，对照代码看完书后，手写了本章变动部分，加入个人理解后的详细注释。

​	内核主体代码：

```nasm
;以下是常量部分，和引导程序约定，方便引导
core_code_seg_sel equ 0x38
core_data_seg_sel equ 0x30
sys_routine_seg_sel equ 0x28
video_ram_seg_sel equ 0x20
core_stack_seg_sel equ 0x18
mem_0_4_gb_seg_sel equ 0x08

;以下是系统header段，用于引导程序加载内核
;==========================================================
SECTION header vstart=0
core_length dd core_end
sys_routine_seg dd section.sys_routine.start
core_data_seg dd section.core_data.start
core_code_seg dd section.core_code.start
core_entry dd start
dw core_code_seg_sel
header_end:

[bits 32]
;以下是公共例程段
;==========================================================
SECTION sys_routine vstart=0

;----------------------------------------------------------
;字符串显示例程，以0结尾
;输入 ds:ebx 串起始线性地址
put_string:                               
push ecx
.getc:
mov cl,[ebx]
or cl,cl
jz .exit
call put_char
inc ebx
jmp .getc

.exit:
pop ecx
retf                               ;段间返回

;----------------------------------------------------------
;字符显示例程，并推进光标 
;输入 cl 字符ascii
put_char:                                   
pushad

;以下取当前光标位置
mov dx,0x3d4
mov al,0x0e
out dx,al
inc dx                             ;0x3d5
in al,dx                           ;高字
mov ah,al

dec dx                             ;0x3d4
mov al,0x0f
out dx,al
inc dx                             ;0x3d5
in al,dx                           ;低字
mov bx,ax                          ;BX=代表光标位置的16位数

cmp cl,0x0d                        ;回车符？
jnz .put_0a
mov ax,bx
mov bl,80
div bl
mul bl
mov bx,ax
jmp .set_cursor

.put_0a:
cmp cl,0x0a                        ;换行符？
jnz .put_other
add bx,80
jmp .roll_screen

.put_other:                               ;正常显示字符
push es
mov eax,video_ram_seg_sel          ;0x800b8000段的选择子
mov es,eax
shl bx,1
mov [es:bx],cl
pop es

;以下将光标位置推进一个字符
shr bx,1
inc bx

.roll_screen:
cmp bx,2000                        ;光标超出屏幕？滚屏
jl .set_cursor

push ds
push es
mov eax,video_ram_seg_sel
mov ds,eax
mov es,eax
cld
mov esi,0xa0                       ;小心！32位模式下movsb/w/d 
mov edi,0x00                       ;使用的是esi/edi/ecx 
mov ecx,1920
rep movsd
mov bx,3840                        ;清除屏幕最底一行
mov ecx,80                         ;32位程序应该使用ECX
.cls:
mov word[es:bx],0x0720
add bx,2
loop .cls

pop es
pop ds

mov bx,1920

.set_cursor:
mov dx,0x3d4
mov al,0x0e
out dx,al
inc dx                             ;0x3d5
mov al,bh
out dx,al
dec dx                             ;0x3d4
mov al,0x0f
out dx,al
inc dx                             ;0x3d5
mov al,bl
out dx,al
popad
ret                                

;----------------------------------------------------------
;以16进制显示一个双字
;输入 edx 待显示的双字
put_hex_dword:
pushad
push ds
mov ax,core_data_seg_sel
mov ds,ax
mov ebx,bin_hex;指向字符表
mov ecx,8;一共8位16进制
.xlt:
rol edx,4;循环左移
mov eax,edx
and eax,0x0000000f;拿到最低4位
xlat;以al 为偏移从 ds:ebx处查表 结果返回 al
push ecx
mov cl,al
call put_char
pop ecx
loop .xlt
pop ds
popad
retf;段间返回

;----------------------------------------------------------
;GDT内安装描述符
;输入 edx:eax 描述符 
;输出 cx 选择子
set_up_gdt_descriptor:
push eax
push ebx
push edx

push ds
push es

mov ebx,core_data_seg_sel
mov ds,ebx

sgdt [pgdt];获取GDTR内容

mov ebx,mem_0_4_gb_seg_sel
mov es,ebx

movzx ebx,word [pgdt];界限
inc bx
add ebx,[pgdt+2];新描述符地址

mov [es:ebx],eax
mov [es:ebx+4],edx

add word [pgdt],8
lgdt [pgdt]

mov ax,[pgdt];新界限
xor dx,dx
mov bx,8
div bx
mov cx,ax;索引
shl cx,3;索引左移3位 设置ti rpl
pop es
pop ds
pop edx
pop ebx
pop eax
retf

;----------------------------------------------------------
;构造描述符
;输入 eax 基地址 ebx 界限 ecx 属性
;输出 edx:eax 描述符
make_seg_descriptor:
mov edx,eax
shl eax,16
or ax,bx; eax 描述符低32位

and edx,0xffff0000;基地址高16位
rol edx,8;循环左移8
bswap edx;交换24-31于0-7  8-15与16-23 基地址安装完成

xor bx,bx;ebx中只剩下 16-19位
or edx,ebx;装配界限 高4位
or edx,ecx;装配属性
retf

;----------------------------------------------------------
;构造门描述符
;输入 eax 段内偏移 bx 目标代码段选择子 cx 属性
;返回 edx:eax 描述符
make_gate_descriptor:
push ebx
push ecx
mov edx,eax
and edx,0xffff0000;偏移地址高16位
or dx,cx;装配属性

and eax,0x0000ffff;低16位偏移
shl ebx,16;选择子左移16位
or eax,ebx
pop ecx
pop ebx
retf;段间返回

;----------------------------------------------------------
;从页映射位串中找到未分配的页，并置1
;输入 无
;输出 eax 物理页地址
allocate_a_4k_page:
push ebx
push ecx
push edx
push ds

mov eax,core_data_seg_sel
mov ds,eax

xor eax,eax
.b1:
bts [page_bit_map],eax;将page_bit_map处的位串的第eax位（从0开始算，二进制位）的值传到CF标志位，并将第eax位置1
jnc .b2;cf位为0时，即位串的第eax位为0时
inc eax
cmp eax,page_map_len*8;page_map_len是位串所占字节
jl .b1

mov ebx,message_3
call sys_routine_seg_sel:put_string
hlt;至此 位串全部为1，无可分配物理页,直接停机了。。。

.b2:
shl eax,12; * 4096即是页的物理地址
pop ds
pop edx
pop ecx
pop ebx
ret;段间返回

;----------------------------------------------------------
;分配一个页，并安装在对应线性地址的页结构上
;输入 ebx 页的线性地址
alloc_inst_a_page:
push eax
push ebx
push esi
push ds

mov eax,mem_0_4_gb_seg_sel
mov ds,eax

;先检查该线性地址所对应的页表是否存在（也就是页目录中对应项是否写入了页表的物理地址）
mov esi,ebx
and esi,0xffc00000;高10位
shr esi,20; 将原来的高10位作为新的低12位页内偏移，右移22 左移2 *4
or esi,0xfffff000;0xfffff000 对应的物理地址是页目录的物理地址
test dword [esi],0x00000001;P位是否为1，即页表是否存在（登记在页目录）
jnz .b1

;不存在 创建
call allocate_a_4k_page
or eax,0x00000007
mov [esi],eax;不存在就申请一个物理页，并将该页的起始物理地址登记在页目录对应项

;至此，输入的线性地址肯定有对应页表了，要申请页，将页的物理地址写
;到页表的对应项。
.b1:
mov esi,ebx
shr esi,10;
and esi,0x003ff000;至此 将输入的线性地址的高10位 转移到esi的中10位
or esi,0xffc00000;esi高10位全1
;至此 esi 是输入的线性地址对应页表的物理地址 所对应的线性地址

and ebx,0x003ff000
shr ebx,10
or esi,ebx;将原来的中10位 作为低12位偏移地址 左移12 右移2 *4
;至此 esi是输入线性地址对应页表项的物理地址 所对应的线性地址
call allocate_a_4k_page;分配一个物理页
or eax,0x00000007
mov [esi],eax;登记分配的物理页，即完成线性地址的页分配

pop ds
pop esi
pop ebx
pop eax
retf

;----------------------------------------------------------
;创建新页目录，并复制当前页目录的内容(内核先把自己页目录搞成用户任务
;需要的结构，然后把自己页目录复制一份，给程序当做页目录)
;新的页目录的所有目录项的值和旧目录一样，所以当切换任务后cr3指向
;新的页目录后，用原来的线性地址仍然可以访问到对应的物理地址
;输入:无
;输出 eax 新页目录的物理地址
create_copy_cur_pdir:
push ds
push es
push esi
push edi
push ebx
push ecx

mov ebx,mem_0_4_gb_seg_sel
mov ds,ebx
mov es,ebx

call allocate_a_4k_page
mov ebx,eax
or ebx,0x00000007
mov [0xfffffff8],ebx
;0xfffffff8对应的物理地址是页目录倒数第二项的物理地址
;将新的页目录暂时作为就页目录的一个页表，不然无法用线性地址访问到
;新的页目录，就没法复制了

mov esi,0xfffff000;ds:si->当前页目录的线性地址
mov edi,0xffffe000;es:edi->新页目录的线性地址
mov ecx,1024
cld
repe movsd;页表完成复制
pop ecx
pop ebx
pop edi
pop esi
pop es
pop ds
retf;段间返回

;----------------------------------------------------------
;终止当前任务，注意执行此例程时，仍是任务的全局空间，执行完毕
;后才是离开任务
terminate_current_task:
mov eax,core_data_seg_sel
mov ds,eax
pushfd
pop edx
test dx,0100_0000_0000_0000B;测试eflags的nt位
jnz .b1
jmp far [program_man_tss]
retf
.b1:
iretd
retf;作者给的代码没有retf，这里写上，是因为万一任务又被执行了，
;会恢复到这里，用retf才可以返回用户局部空间

sys_routine_end:

;系统核心的数据段 
;==========================================================
SECTION core_data vstart=0                 
pgdt             dw  0             ;用于设置和修改GDT 
dd  0

page_bit_map     db  0xff,0xff,0xff,0xff,0xff,0x55,0x55,0xff
db  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
db  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
db  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
db  0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55
db  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
page_map_len     equ $-page_bit_map

;符号地址检索表
salt:
salt_1           db  '@PrintString'
times 256-($-salt_1) db 0
dd  put_string
dw  sys_routine_seg_sel

salt_2           db  '@ReadDiskData'
times 256-($-salt_2) db 0
dd  read_hard_disk_0
dw  sys_routine_seg_sel

salt_3           db  '@PrintDwordAsHexString'
times 256-($-salt_3) db 0
dd  put_hex_dword
dw  sys_routine_seg_sel

salt_4           db  '@TerminateProgram'
times 256-($-salt_4) db 0
dd  terminate_current_task
dw  sys_routine_seg_sel

salt_item_len   equ $-salt_4
salt_items      equ ($-salt)/salt_item_len

message_0        db  '  Working in system core,protect mode.'
db  0x0d,0x0a,0

message_1        db  '  Paging is enabled.System core is mapped to'
db  ' address 0x80000000.',0x0d,0x0a,0

message_2        db  0x0d,0x0a
db  '  System wide CALL-GATE mounted.',0x0d,0x0a,0

message_3        db  '********No more pages********',0

message_4        db  0x0d,0x0a,'  Task switching...@_@',0x0d,0x0a,0

message_5        db  0x0d,0x0a,'  Processor HALT.',0


bin_hex          db '0123456789ABCDEF'
;put_hex_dword子过程用的查找表 

core_buf   times 512 db 0          ;内核用的缓冲区

cpu_brnd0        db 0x0d,0x0a,'  ',0
cpu_brand  times 52 db 0
cpu_brnd1        db 0x0d,0x0a,0x0d,0x0a,0

;任务控制块链
tcb_chain        dd  0

;内核信息
core_next_laddr  dd  0x80100000    ;内核空间中下一个可分配的线性地址        
program_man_tss  dd  0             ;程序管理器的TSS描述符选择子 
dw  0

core_data_end:

;内核代码段
;==========================================================
SECTION core_code vstart=0

;----------------------------------------------------------
;在ldt内安装描述符
;输入 edx:eax 描述符 ebx tcb线性基地址
;输出 cx 描述符选择子
fill_descriptor_in_ldt:
push eax
push edx
push edi
push ds

mov ecx,mem_0_4_gb_seg_sel
mov ds,ecx
mov edi,[ebx+0x0c];从tcb获得ldt基地址

xor ecx,ecx
mov cx,[ebx+0x0a];获得ldt界限
inc cx;大小

mov [edi+ecx+0x00],eax
mov [edi+ecx+0x04],edx

add cx,8
dec cx

mov [ebx+0x0a],cx;重新写入界限

mov ax,cx
xor dx,dx
mov cx,8
div cx

mov cx,ax;索引号
shl cx,3
or cx,0000_0000_0000_0100B
;ti位置1 表示在ldt中，rpl暂时为0

pop ds
pop edi
pop edx
pop eax
ret

;----------------------------------------------------------
;加载并重定位程序
;输入 push 逻辑扇区 push tcb基地址
;输出 无
load_relocate_program:
pushad
push ds
push es

mov ebp,esp;通过ebp访问栈内参数

mov ecx,mem_0_4_gb_seg_sel
mov es,ecx

;清空当前页目录前半部分（低2gb空间，暂时将系统任务地址空间的低
;2gb来加载程序，反正系统任务又不上，加载好后就可以把系统的页目
;录复制一份给，这样加载不同程序，便生成了不同的页目录，因为每次
;都将低2gb对应的页目录项清空，再利用alloc_inst_a_page重建了）
mov ebx,0xfffff000
xor esi,esi
.b1:
mov dword [es:ebx+esi*4],0x00000000;ebx对应的物理地址是页目录表
inc esi
cmp esi,512
jl .b1

;以下开始分配内存并加载用户程序
mov eax,core_data_seg_sel
mov ds,eax

mov eax,[ebp+12*4];起始扇区号
mov ebx,core_buf
call sys_routine_seg_sel:read_hard_disk_0

;判断程序大小
mov eax,[core_buf];大小
mov ebx,eax
and ebx,0xfffff000
add ebx,4096;4kb对齐
test eax,0x00000fff
cmovnz eax,ebx;eax不4kb对齐 就用对齐后的ebx

mov ecx,eax
shr ecx,12;ecx即对应的页数,大循环

mov eax,mem_0_4_gb_seg_sel
mov ds,eax

mov eax,[ebp+12*4];扇区号
mov esi,[ebp+11*4];tcb基地址

.b2:
mov ebx,[es:esi+0x06];tcb内记载的可分配线性空间的起始地址
add dword [es:esi+0x06],0x1000;分配4KB，所以新分配地址+0x1000
call sys_routine_seg_sel:alloc_inst_a_page;将该线性页和对应物理页对应
push ecx
mov ecx,8;一个页大小要8个扇区填满
.b3:
call sys_routine_seg_sel:read_hard_disk_0
inc eax
loop .b3

pop ecx;下一个4096字节
loop .b2

;在内核地址空间创建用户任务的TSS，因为内核要随时都能访问所有任务的TSS
;所以TSS必然要放在内核地址空间里
mov eax,core_data_seg_sel
mov ds,eax

mov ebx,[core_next_laddr];内核可分配的线性空间
call sys_routine_seg_sel:alloc_inst_a_page
add dword [core_next_laddr],0x1000;新的可分配的线性地址

mov [es:esi+0x14],ebx;tcb中登记tss线性地址
mov word [es:esi+0x12],103;登记界限

;在用户任务的局部地址空间创建LDT，因为ldt只有在切换成前台任务时，才会
;被内核访问，因此卸载局部地址空间也行。
mov ebx,[es:esi+0x06];从tcb中取得可分配的线性地址
add dword [es:esi+0x06],0x1000;新的可分配的
call sys_routine_seg_sel:alloc_inst_a_page
mov [es:esi+0x0c],ebx;tcb中登记ldt线性基地址

;建立程序代码段描述符
mov eax,0x00000000
mov ebx,0x000fffff
mov ecx,0x00c0f800;4Kb粒度，结合基地址和界限，0-4GB的平坦模型
call sys_routine_seg_sel:make_seg_descriptor
mov ebx,esi;tcb基地址
call fill_descriptor_in_ldt
or cx,0000_0000_0000_0011B;RPL置3

mov ebx,[es:esi+0x14];tcb中获取tss
mov [es:ebx+76],cx;填写tss 的 cs域
;再不必往tcb中登记cs选择子

;程序数据段描述符
mov eax,0x00000000
mov ebx,0x000fffff                 
mov ecx,0x00c0f200                 ;4KB粒度的数据段描述符，特权级3
call sys_routine_seg_sel:make_seg_descriptor
mov ebx,esi                        ;TCB的基地址
call fill_descriptor_in_ldt
or cx,0000_0000_0000_0011B         ;设置选择子的特权级为3

;由于平坦模型 所有段寄存器的选择子对应的描述符都能访问0-4GB
mov ebx,[es:esi+0x14]              ;从TCB中获取TSS的线性地址
mov [es:ebx+84],cx                 ;填写TSS的DS域 
mov [es:ebx+72],cx                 ;填写TSS的ES域
mov [es:ebx+88],cx                 ;填写TSS的FS域
mov [es:ebx+92],cx                 ;填写TSS的GS域

;将数据段作为用户任务的固有堆栈
mov ebx,[es:esi+0x06];从tcb中取得可分配线性地址
add dword [es:esi+0x06],0x1000;新可分配线性地址
call sys_routine_seg_sel:alloc_inst_a_page

mov ebx,[es:esi+0x14];tcb中获取tss基地址
mov [es:ebx+80],cx;填写ss域
mov edx,[es:esi+0x06]
mov [es:ebx+56],edx;将指针设置为堆栈的上限，刚好为可分配的新地址

;在用户任务局部空间创建0特权级堆栈
mov ebx,[es:esi+0x06]
add dword [es:esi+0x06],0x1000;分配线性地址
call sys_routine_seg_sel:alloc_inst_a_page

mov eax,0x00000000
mov ebx,0x000fffff
mov ecx,0x00c09200;4Kb粒度 向上扩展（普通数据段用作栈段） dpl0
call sys_routine_seg_sel:make_seg_descriptor
mov ebx,esi;tcb基地址
call fill_descriptor_in_ldt
or cx,00000000_00000000B;rpl 0

mov ebx,[es:esi+0x14];tcb中获取tss基地址
mov [es:ebx+8],cx;填写tss中 ss0
mov edx,[es:esi+0x06]
mov [es:ebx+4],edx;tss 的esp0  （上界刚好是新可分配的线性地址）

;在用户任务的局部地址空间内创建1特权级堆栈
mov ebx,[es:esi+0x06]              ;从TCB中取得可用的线性地址
add dword [es:esi+0x06],0x1000
call sys_routine_seg_sel:alloc_inst_a_page

mov eax,0x00000000
mov ebx,0x000fffff
mov ecx,0x00c0b200                 ;4KB粒度的堆栈段描述符，特权级1
call sys_routine_seg_sel:make_seg_descriptor
mov ebx,esi                        ;TCB的基地址
call fill_descriptor_in_ldt
or cx,0000_0000_0000_0001B         ;设置选择子的特权级为1

mov ebx,[es:esi+0x14]              ;从TCB中获取TSS的线性地址
mov [es:ebx+16],cx                 ;填写TSS的SS1域
mov edx,[es:esi+0x06]              ;堆栈的高端线性地址
mov [es:ebx+12],edx                ;填写TSS的ESP1域 

;在用户任务的局部地址空间内创建2特权级堆栈
mov ebx,[es:esi+0x06]              ;从TCB中取得可用的线性地址
add dword [es:esi+0x06],0x1000
call sys_routine_seg_sel:alloc_inst_a_page

mov eax,0x00000000
mov ebx,0x000fffff
mov ecx,0x00c0d200                 ;4KB粒度的堆栈段描述符，特权级2
call sys_routine_seg_sel:make_seg_descriptor
mov ebx,esi                        ;TCB的基地址
call fill_descriptor_in_ldt
or cx,0000_0000_0000_0010B         ;设置选择子的特权级为2

mov ebx,[es:esi+0x14]              ;从TCB中获取TSS的线性地址
mov [es:ebx+24],cx                 ;填写TSS的SS2域
mov edx,[es:esi+0x06]              ;堆栈的高端线性地址
mov [es:ebx+20],edx                ;填写TSS的ESP2域 


;重定位salt
mov eax,mem_0_4_gb_seg_sel
mov es,eax

mov eax,core_data_seg_sel
mov ds,eax

cld;esi edi 正向增大

mov ecx,[es:0x0c];由于程序被从线性地址0处加载 所以0x0c处是
;u-salt条目数
mov edi,[es:0x08];u_salt的偏移地址（由于从0开始加载，偏移地址即是线性地址）

.b4:
push ecx
push edi

mov ecx,salt_items;内循环 常量
mov esi,salt
.b5:
push edi
push esi
push ecx
mov ecx,64
repe cmpsd;一次比4字节比64次
jnz .b6
mov eax,[esi];如果匹配，那么esi 恰好是c_salt对应条目的偏移地址
mov [es:edi-256],eax;
mov ax,[esi+4];选择子
or ax,0000_0000_0000_0011B;RPL置3
mov [es:edi-252],ax;回写调用门选择子 到 u_salt对应项

.b6:
pop ecx
pop esi
add esi,salt_item_len;下一个c_salt
pop edi;u_salt 也要回到对应条目偏移0处重新比较
loop .b5

pop edi
add edi,256;下一个u_salt条目
pop ecx
loop .b4

;在gdt中登记ldt
mov esi,[ebp+11*4];tcb基地址
mov eax,[es:esi+0x0c];ldt起始地址
movzx ebx,word [es:esi+0x0a];段界限
mov ecx,0x00408200;ldt描述符属性 dpl 0
call sys_routine_seg_sel:make_seg_descriptor
call sys_routine_seg_sel:set_up_gdt_descriptor
mov [es:esi+0x10],cx;将ldt选择子登记到tcb

mov ebx,[es:esi+0x14];tcb中获取tss线性基地址
mov [es:ebx+96],cx;tss填上ldt选择子

mov word [es:ebx+0],0;反向链（上一级任务tss选择子）位0

mov dx,[es:esi+0x12];tss段长度（界限）
mov [es:ebx+102],dx

mov word [es:ebx+100],0;T=0 不开启任务调试

mov eax,[es:0x04];从任务的4GB地址空间获取入口地址
mov [es:ebx+32],eax;填写tss的eip

pushfd
pop edx
mov [es:ebx+36],edx;填写tss的eflags

;在gdt中登记tss
mov eax,[es:esi+0x14];tcb中获取tss线性基地址
movzx ebx,word [es:esi+0x12];段界限
mov ecx,0x00408900;tss描述符
call sys_routine_seg_sel:make_seg_descriptor
call sys_routine_seg_sel:set_up_gdt_descriptor
mov [es:esi+0x18],cx;tcb中登记tss选择子

;创建用户任务页目录
call sys_routine_seg_sel:create_copy_cur_pdir
mov ebx,[es:esi+0x14];tcb中获取tss线性基地址
mov dword [es:ebx+28],eax;填写tss的cr3（page director base 
;address register）

pop es
pop ds
popad
ret 8;跳过栈中参数

;----------------------------------------------------------
;在tcb链上追加tcb （现阶段没luan用 下一章抢占式任务切换才有用）
;输入 ecx=tcb线性基地址
append_to_tcb_link:
push eax
push edx
push ds
push es

mov eax,core_data_seg_sel
mov ds,eax
mov eax,mem_0_4_gb_seg_sel
mov es,eax

mov dword [es:ecx+0x00],0;当前tcb指针域清0（因为是链上最后一个）

mov eax,[tcb_chain]
or eax,eax;为0为空？
jz .notcb

.search:
mov edx,eax
mov eax,[es:edx+0x00];访问指针域
or eax,eax
jnz .search;如果有下一级tcb的话 去访问
mov [es:edx+0x00],ecx;没有的话就把当前tcb的地址写上
jmp .retpc

.notcb:
mov [tcb_chain],ecx;如空，则直接写在tcb_chain对应空间

.retpc:
pop es
pop ds
pop edx
pop eax
ret

;----------------------------------------------------------
;内核代码入口
;无输入 无输出
start:
mov ecx,core_data_seg_sel
mov ds,ecx

mov ecx,mem_0_4_gb_seg_sel
mov es,ecx

mov ebx,message_0
call sys_routine_seg_sel:put_string

;显示处理器信息，代码被省略了，不写了

;准备打开分页机制
;创建系统内核页目录表pdt 并清0
mov ecx,1024
mov ebx,0x00020000;页目录物理地址
xor esi,esi
.b1:
mov dword [es:ebx+esi],0x00000000;清零
add esi,4
loop .b1

;页目录最后一项位向自己，值为页目录自身的物理地址
;不这么做不方便拿到页目录的线性地址来访问它。
mov dword [es:ebx+4092],0x0020003

;在页目录内创建低1MB（0x00000000开始的）线性地址对应的目录项
mov dword [es:ebx+0],0x00021003;高20位才是该目录项对应页表的物理地址
;低12位 是属性

;创建该目录项的页表，并初始化页表项
mov ebx,0x00021000
xor eax,eax
xor esi,esi

.b2:
mov edx,eax
or edx,0x00000003
mov [es:ebx+esi*4],edx;登记页表里每一个项对应页的物理地址
add eax,0x1000
inc esi
cmp esi,256;(仅仅先登记低1MB线性地址对应的物理地址)
jl .b2

.b3:
mov dword [es:ebx+esi*4],0x00000000
inc esi
cmp esi,1024
jl .b3

;设置cr3寄存器 ，并开启页功能
mov eax,0x00020000 ;pcd pwt =0
mov cr3,eax

mov eax,cr0
or eax,0x80000000
mov cr0,eax;最高位pg置1 开启分页机制，从此再也不能直接用物理地址了

;在页目录内创建线性地址0x80000000对应的目录项
mov ebx,0xfffff000;0xfffff000是页目录的线性地址
mov esi,0x80000000;
shr esi,22
shl esi,2;右移22位将高10位当做最低12位，再*4作页内偏移
mov dword [es:ebx+esi],0x00021003;写入目录项（页表物理地址和属性）

;将gdt中段描述符 的线性基地址 都迁移到0x80000000 上（高2gb）
sgdt [pgdt]
mov ebx,[pgdt+2]
or dword [es:ebx+0x10+4],0x80000000
or dword [es:ebx+0x18+4],0x80000000
or dword [es:ebx+0x20+4],0x80000000
or dword [es:ebx+0x28+4],0x80000000
or dword [es:ebx+0x30+4],0x80000000
or dword [es:ebx+0x38+4],0x80000000
;除了0_4_gb这个段描述符的线性基地址没改，因为它是用来从0-4gb的段
;可以表示线性空间
add dword [pgdt+2],0x80000000;gdtr也要用迁移后的线性地址
lgdt [pgdt]
jmp core_code_seg_sel:flush ;刷新段寄存器（因为选择子对应的描述符
;的线性基地址改了）
flush:
mov eax,core_stack_seg_sel
mov ss,eax
mov eax,core_data_seg_sel
mov ds,eax

mov ebx,message_1
call sys_routine_seg_sel:put_string

;以下开始安装调用门，特权级之间的转移必须用门
mov edi,salt
mov ecx,salt_items
.b4
push ecx
mov eax,[edi+256];
mov bx,[edi+260]
mov cx,1_11_0_1100_000_00000B;属性
call sys_routine_seg_sel:make_gate_descriptor
call sys_routine_seg_sel:set_up_gdt_descriptor
mov [edi+260],cx;回写门描述符
add edi,salt_item_len
pop ecx
loop .b4

;测试门
mov ebx,message_2
call far [salt_1+256]

;为程序管理器prgman（内核任务）TSS分配内存空间
mov ebx,[core_next_laddr]
call sys_routine_seg_sel:alloc_inst_a_page
add dword [core_next_laddr],0x1000;新的可分配的线性地址

;填写tss必要项目
mov word [es:ebx+0],0;反向链0
mov eax,cr3
mov dword [es:ebx+28],eax;登记cr3
mov word [es:ebx+96],0;没有ldt 
mov word [es:ebx+100],0;关闭任务调试 T=0
mov word [es:ebx+102],103;不使用I/O位图

;创建prgman TSS 描述符 并安装到gdt
mov eax,ebx;tss线性基地址
mov ebx,103;界限
mov ecx,0x00408900;tss 描述符 特权级0
call sys_routine_seg_sel:make_seg_descriptor
call sys_routine_seg_sel:set_up_gdt_descriptor
mov [program_man_tss_4],cx;将prgman tss选择子保存在内核数据段

;tr是任务进行的标志，我们的prgman实际执行了，但是不算任务
ltr cx
;现在处理器认为 prgman任务执行了

;在内核空间 创建用户任务的tcb，这章的tcb较简洁
mov ebx,[core_next_laddr]
call sys_routine_seg_sel:alloc_inst_a_page
add dword [core_next_laddr],0x1000;新的可分配的线性地址

mov dword [es:ebx+0x06],0;用户任务局部地址空间的起始线性地址
mov word [es:ebx+0x0a],0xffff;登记ldt初始界限（0-1=0xffff）
mov ecx,ebx
call append_to_tcb_link;tcb添加到tcb链

push dword 50
push ecx;tcb基地址

call load_relocate_program
mov ebx,message_4
call sys_routine_seg_sel:put_string

call far [es:ecx+0x14]; tcb内偏移0x14是tss选择子

mov ebx,message_5
call sys_routine_seg_sel:put_string
hlt

core_code_end:
core_end:


```





