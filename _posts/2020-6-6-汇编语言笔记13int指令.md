---
layout: post
title: 汇编语言笔记13int指令
subtitle: 汇编语言笔记13int指令
date: 2020-06-6
author: nightmare-man
tags: 8086汇编
---

# 汇编语言笔记13int指令

### 0x00 int指令

​		int指令 可以引起中断，其格式为**int n**   n即为对应中断类型码，中断过程如下：

​		（1）取中断类型码n

​		（2）标志寄存器入栈，IF=0 TF=0

​		（3）CS IP入栈

​		（4）IP=4 * N CS= 4* N+2

​		然后转入n号中断的中断处理程序，可以用int 指令调用任何一个中断的中断处理程序，例如：

```assembly
assume cs:code
code segment
start:		mov ax,0b800h
			mov es,ax
			mov byte ptr es:[12*160+4*2],'!'
			int 0
code ends
end start
```

![QQ截图20200606094619](/assets/img/QQ截图20200606094619.png)

​		运行结果如图，第一个黑色的'!'是我们程序里写的 第二个绿字则是之前我们另一个程序安装的0号中断的中断处理程序显式的overflow，说明中断处理程序安装后没有随着原程序结束而释放，而且int 0指令成功调用了对应的中断处理程序

​		

### 0x01 编写供应用程序调用的中断例程

![QQ截图20200606094935](/assets/img/QQ截图20200606094935.png)

​		一样的还是分为三个部分：（1）编写对应的中断处理程序 （2）写入内存固定地方（一般选0000:0200h） （3）设置中断向量表中对应的表项

```assembly
assume cs:code,ss:stack
code segment
start:	mov ax,cs
		mov ds,ax
		mov si,offset do7c
		
		mov ax,0
		mov es,ax
		mov di,0200h
		
		mov cx,offset do7c_end-offset do7c
		cld
		
		rep movsb
		
		mov word ptr es:[7ch*4],0200h
		mov word ptr es:[7ch*4+2],0;至此安装完成
		
		mov ax,1000
		int 7ch;调用
		
		mov ax,4c00h
		int 21h
do7c:	mul ax
		iret
do7c_end:nop
code ends
end start		
```

![QQ截图20200606100402](/assets/img/QQ截图20200606100402.png)

​		上述代码运行正确，另外 我在上一篇笔记中 对iret的用法 认识错误  ，iret指令在中断处理程序结尾调用时，相当于执行 pop ip pop cs popf, 中断处理程序结尾用mov ax,4c00h int 21h 这种就直接返回到dos 不用再用iret

![QQ截图20200606100824](/assets/img/QQ截图20200606100824.png)

```assembly
assume cs:code,ss:stack
stack segment
		db 64 dup (0)
stack ends
data segment
		db 'welcometomasm',0
data ends
code segment
start:	mov ax,stack
		mov ss,ax
		mov sp,40h

		mov ax,cs
		mov ds,ax
		mov si,offset do7c
		
		mov ax,0
		mov es,ax
		mov di,200h
		
		mov cx,offset do7c_e-offset do7c
		cld
		
		rep movsb
		
		mov word ptr es:[7ch*4],200h
		mov word ptr es:[7ch*4+2],0;安装完成
		
		mov ax,data
		mov ds,ax
		mov si,0
		int 7ch;调用 测试
		
		mov ax,4c00h
		int 21h
		
do7c:	push si
		push cx
s:		mov cl,ds:[si]
		mov ch,0
		jcxz ok
		and cl,11011111b
		mov ds:[si],cl
		inc si
		jmp short s
ok:		pop cx
		pop si
		iret
do7c_e:	nop
code ends
end start
```

![QQ截图20200606102841](/assets/img/QQ截图20200606102841.png)

​		上述代码运行正确

### 0x02 对int iret和栈的深入理解

​		![QQ截图20200606103643](/assets/img/QQ截图20200606103643.png)

​		如果我们把loop 指令看成一个函数 那么这个函数的传入 参数有 cx（循环的次数）ds:si 跳转地址

ds不用传入 因为进入中断处理程序是push 标志寄存器 push cs push ip    ds可以从栈中的cs里读，那么si 呢 我们可以设置标号  通过标号的偏移地址来读

```assembly
assume cs:code
code segment
start:	mov ax,cs
		mov ds,ax
		mov si,offset do7c
		
		mov ax,0
		mov es,ax
		mov di,200h
		
		mov cx,offset do7c_e-offset do7c
		
		rep movsb
		
		mov word ptr es:[7ch*4],200h
		mov word ptr es:[7ch*4+2],0;安装好了
		
		mov cx,80
		mov ax,0b800h
		mov ds,ax
		mov si,0
s0:		mov ds:[12*160+si],'!'
		mov ds:[12*160+si+1],2
		add si,2
		int 7ch;如果cx 不等于0 跳转到s0 否则继续下去
		
s1:		mov ax,4c00h
		int 21h
		
do7c:	push bp
		push ax;栈顶分别是 ax bp ip cs flag
		mov bp,sp
		dec cx
		cmp cx,0
		je fin
		mov ax,ss:[bp+4]
		sub ax,offset s1-offset s0
		mov ss:[bp+4],ax
fin:	pop ax
		pop bp
		iret
do7c_e:	nop
code ends
end start
```

![QQ截图20200606105739](/assets/img/QQ截图20200606105739.png)

​		上述代码运行正确，获得跳转的偏移地址很简单，因为iret 会pop ip pop cs popf 所以只要在iret之前改掉栈中原来保存的ip就好，改成多少呢？ 原来ip 是指向s1的 我们要跳到s0 所以原ip要减小offset s1-offset s0

![QQ截图20200606110218](/assets/img/QQ截图20200606110218.png)

![QQ截图20200606110240](/assets/img/QQ截图20200606110240.png)

​		（1）上面跳转最大位移是max（offset s，ffffh-0ffset s）,因为只能修改ip

​		（2）

```assembly
assume cs:code
data segment
		db 'conversation',0
code segment
start:	mov ax,cs
		mov ds,ax
		mov si,offset do7c
		mov ax,0
		mov es,ax
		mov di,200h
		mov cx,offset do7c_e-offset do7c
		rep movsb
		mov word ptr es:[7ch*4],200h
		mov word ptr es:[7ch*4+2],0;安装完成
		
		mov ax,data
		mov ds,ax
		mov ax,0b800h
		mov es,ax
		mov si,0
		mov di,0
s0:		cmp byte ptr ds:[si],0
		je ok
		mov al,ds:[si]
		mov es:[2000+di],al
		mov byte ptr es:[2000+di+1],2
		inc si
		add di,2
		mov bx,offset s0-offset ok
		int 7ch;跳转到标号s0
ok:		mov ax,4c00h
		int 21h
		
do7c:	push bp
		push ax;栈顶 ax bp ip cs 标志
		mov bp,sp
		mov ax,[bp+4]
		add ax,bx;ax=ax+bx=offset ok+offset s0-offset ok =offset s0
		mov [bp+4],ax
		pop ax
		pop bp
		iret
do7c_e:	nop
code ends
end start
		
```

![QQ截图20200606114315](/assets/img/QQ截图20200606114315.png)

​		上述代码运行正确

### 0x03 BIOS和DOS所提供的中断例程

