---
layout: post
title: CSAPP笔记02程序的机器级表示（下）
subtitle: CSAPP笔记02程序的机器级表示（下）
date: 2020-08-04
author: nightmare-man
tags: 计算机组成原理
---
# CSAPP笔记02程序的机器级表示（下）

### 0x00 过程

​	过程是程序中一种重要的**抽象**，它将一段代码封装，可以传递参数和返回值，在程序的不同地方调用。

​	过程的表现形式多样，可以是函数（function）、方法（method）、子例程（subroutine）、处理函数（handler），不同的形式主要是功能不同。

​	要提供对过程的机器级支持，需要实现三个机制，假设P调用Q，Q执行后返回到Q:

​	①传递控制。在进入过程Q的时候，PC要能设置成Q的代码的起始地址，在返回时，要能返回到P的下一条指令。

​	②传递数据。P必须能向Q传递一个或者多个参数，而且Q能向P返回一个值。

​	③分配和释放内存。在开始时，要能给Q的局部变量分配空间，在Q结束时，能够释放这些空间。

​	为了减少过程调用的开销，只需要实现上面的三个机制即可。

​	

​	**运行时栈**

​	函数的调用机制在于使用了**栈数据结构的后进先处的内存管理原则**，程序的栈既可以用来实现上述的三个机制（传递参数 分配占空间给局部变量，将返回地址存在栈中）。

​	当过程需要的储存空间超过了寄存器能够存放的大小后，就要分配栈空间来储存局部变量了。这个过程称为栈帧。

​	![image-20200804152544654](/assets/img/image-20200804152544654.png)

​	当过程P调用过程Q的时候，会把返回地址压入栈中，指明Q返回时要从P的哪个位置继续执行，这个返回地址时P的帧栈的一部分。

​	Q的代码会扩展当前栈的的边界，分配它的帧栈的空间，在这个空间中，用来保存寄存器的值，分配局部变量空间，为它的调用过程设置参数（也在栈中，函数的嵌套调用），大多数过程的帧栈都是定长的，在过程开始的时候分配好了（subq $size,%rsp）。但是有些过程需要变长的帧。

​	为了提高空间和时间效率，x86-64过程只分配自己所需要额帧栈（过程内调用的其他过程的不用负责）。实际上传递参数和局部变量都可以使用寄存器实现，而且寄存器的读写速度远远快于栈（内存）。

​	

​	**转移控制**

​	将控制从过程P转移到过程Q，只需要将PC设置到Q的代码的起始位置。返回时处理器需要记录P过程内的继续执行的位置。

​	x86-64使用**call**指令来转移控制，call指令会将当前PC的地址压入栈，并将PC设置为被调用过程的其实地址。压入的地址称为**返回地址**，（call指令后面那条指令的地址）。对应的返回指令**ret**，会从栈中弹出一个地址，并将PC设置为该地址。

​	![image-20200804153848117](/assets/img/image-20200804153848117.png)

​	同jmp一样，call跳转的地址可以是直接给出的，也可以是间接给出的。（直接地址会写在编码里，间接地址则是寄存器里或者内存空间里）。

​	

​	**数据传送**

​	当调用过程时，除了需要转移控制，还可能包括把数据作为参数传递，并且从过程返回时还有可能有一个返回值。

​	在前面的代码中，我们一直使用的是寄存器来传递参数，因为在两个过程切换时，通用寄存器是共用的，同样的也可以用通用寄存器来返回数据。

​	一般而言，使用以下6个寄存器来传递参数：

![image-20200804155231588](/assets/img/image-20200804155231588.png)

​	如果要传递的参数超过6个，那么需要用栈来传递，也就是将栈空间扩展（地址向下扩展）7-n参数的全部大小，然后将参数7-n依次写入（push）栈中。（一般而言，约定最右边的参数最先push，所以栈顶是最左边的参数。）

​	然后在被调用的过程里，通过访问调用过程的栈帧，即可读取参数（需要知道此时参数相对栈顶的偏移位置）。

​	

​	**栈上的局部储存**

​	同样的，前面的代码使用局部变量时，都是使用寄存器保存。但是寄存器不够用时，需要使用栈空间来保存局部变量，有以下情况要使用栈空间来保存局部变量：

​	①寄存器不够用

​	②对一个局部变量要取地址"&"使用，因此必须放在内存（栈）里

​	③局部的数组或者结构，要通过地址偏移访问

​	通过减小栈顶指针，即可从栈上分配空间，分配的结果时栈帧的一部分，在过程结束的时候，重新给栈顶指针恢复，就可以释放分配的栈空间。

```c
long caller(){
    long arg1=534;
    long arg2=100;
    long sum=swap(&arg1,&arg2);
    return sum;
}
caller:
subq $16,%rsp
movq $534,(%rsp)
movq $100,8(%rsp)
leaq 8(%rsp),%rsi
movq %rsp,%rdi
call swap
```



​	**寄存器的储存空间**

​	寄存器组时所有过程公用的资源，虽然在同一时刻只有一个过程时活动的（前台），**但是我们必须保证被调用的过程不会覆盖调用者稍后使用的寄存器的值**，为此，有如下约定：

​	寄存器%rbx %rbp 和%r12-%r15被划分为**被调用者保存寄存器**，也就是被调用者如果要修改这些寄存器，必须先保存，然后使用，使用完毕后恢复（在过程开始时push压入栈，结束前pop出栈，注意顺序相反）。

​	所有其他的寄存器，（除了栈指针），都是**调用者保存寄存器**，调用者如果需要这些值在调用后仍然存在，需要自己保存。



​	**递归过程**

​	由于实现的过程调用机制，我们可以用过程自己调用自己，和调用其他过程没有任何区别。这种调用自己的行为称为递归。



### 0x01 数组分配和访问

​	数组时一种将标量数据聚集成更大数据类型的方式。对于c语言，一块连续的内存空间即可作为一个数组，并且可以通过指针访问不同索引的元素。并且C语言支持指针运算，在机器代码中，会翻译成地址计算。

​	对于T A[n]，会在内存中分配一个sizeof（T）* n字节的连续的空间，A是一个指针，指向这个连续空间的首地址。通过索引i（0-n-1）来访问，对应的地址时A+i*sizeof(T).



​	**指针运算**

​	c语言允许对指针进行运算，而计算的结果要根据指针的大小进行伸缩。如果p是一个指向数据类型T的指针，那么p+i，对应的地址运算时x(p)+i * sizeof(T).

​	&操作符是给出该对象的一个指针，而*操作符是对指针的一个引用。同样 * (p+i),引用的是数组p的第i个元素。

​	

​	**嵌套数组**

​	嵌套的数组，就是数组中的元素是数组，而数组本质是指针，所以，**也就是一个数组里的每一个元素都是指针**

​	int A[5] [3] ；对应是一个数组有5个元素，每个元素都是一个数组（指针），每个指针都指向自己所表示的数组的首地址。

![image-20200804163525471](/assets/img/image-20200804163525471.png)

​	也就是A[0]里保存的是Xa。对T D[R] [C]对应的数组元素D [I] [J]的内存地址为：X0+ L(C*i+J) * sizeof（T）



​	**定长数组**

​	针对下面的c代码：

```c
for(j=0;j<n;j++){
    result+=A[i][j]*B[j][k];
}
```

​	这种数组访问规律，可以发现，访问的总是A[i]指针对应的数组，因此编译器会提前算出A[I]指针的值，也就是A[I]对应数组的首地址。而不是每次都用公式 Xa+ sizeof（T）* （i*n+j）来算地址。对应的优化后的c语言：

```assembly
int *Aptr=&A[i][0]
int *Bptr=&[0][k]
do{
	result+=*Aptr * *Bptr
	Aptr++;指针运算，指向下一个元素
	Bptr+=N;指针运算，指向下N个元素，扩展成二维即使下一行同列
}while (Bptr!=Bend)
```

​	

​	**变长数组**

​	C99引入了变长数组，即在编译时维度（宽度）未定，运行时才确定。

```c
int var_ele(long n,int A[n][n],long i,long j){
    return A[i][j];
}
```

​	参数n必须在A[n] [n]前面，这样才能计算出数组的维度。

```assembly
var_ele:;n in %rdi,A in %rsi,i in %rdx,j in %rcx
imulq %rdx,%rdi;caculate n*i
leaq (%rsi,%rdi,4),%rax;计算 A[i][0]的首地址
movl (%rax,%rcx,4),%eax;将A[i][j]地址处的内容读到eax,因为结果是int
ret
```

​	变长数组相对于定长数组，主要是由于维度在寄存器或者内存空间里，编译器无法在计算地址是利用leaq来算，**而要用imul，但是乘法计算的代价是很高的。**

​	但是同样的，对于多次访问二维数组T A[5] [k]，（k是变动的）处理器也会和定长数组一样优化成A[5] [0] + K * sizeof（T），而不是每次都重新计算。



### 0x02 异质的数据结构

​	c语言有两种**将不同类型的对象组合到一起创建新数据类型**的机制，**结构（struct）**，将多个对象集合到一个单位里；**联合（union）**，用多种数据类型来引用一个对象。



​	 **结构struct**

​	struct将不同的（也可以相同呀~）数据类型聚合到一个对象中，用名字来引用组成该结构的各个部分。类似于数组，该对象内的各个部分在一个连续的内存中，通过偏移来访问/引用各个部分。

```c
struct rec{
    int i;
    int j;
    int a[2];
   	int *p;
}new_rec;
//rec是构建的新类型 后面可以用struct rec来创建
//new_rec是创建时即声明的一个变量，类型就是struct recSS
```

​	![image-20200804171357703](/assets/img/image-20200804171357703.png)

​	这个结构的各个字段的偏移如上图，要产生一个指向结构内部某个字段的指针，只需要该结构struct的地址加上在结构内的偏移。



​	**联合**

​	**联合提供一种机制，以多种类型来引用一个对象（内存块/内存对象）。**

​	对于下面的声明：

```c
struct S3{
    char c;
    int i[2];
    double v;
}
union U3{
    char c;
    int i[2];
    double v;
}
```

​	这两个类型对应的对象在x86-64 linux机器上编译时，各个字段的偏移和对象的完整大小如下：

![image-20200804172041878](/assets/img/image-20200804172041878.png)

​	先看S3的各个字段，发现偏移很奇怪，比如i的偏移，为啥不是1？ 即使i的偏移时4，那么v的偏移为什么不是4+8=12？ 最后大小时24？

​	**实际上，这和数据对齐有关，将在下面讲到。**

​	再看U3，每个字段的偏移都是0，也就是说，实际上对每个字段的引用都是从对象的基地址开始的，因此对一个对象里一个字段的修改会同时改变其他字段。（**联合对象字段的使用是互斥的**）

​	利用联合，可以实现数据转换（不是数值相同转换用其他数据类型表示，而是二进制位不变，显示其他类型的数值）。如利用联合来显示一个double数据对应的unsigned long的值：

```c
unsigned long double2bits(double d){
    union{
        double d;
        unsigned long u;
    }temp;
    temp.d=d;
    return temp.u;
}
```

​	反过来干也可以。由于是二进制位的表示，因此需要注意字节序。