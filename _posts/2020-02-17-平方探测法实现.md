---
layout: post
title: 平方探测法实现
subtitle: 平方探测法实现
date: 2020-02-17
author: nightmare-man
tags: 数据结构与算法
---
# 		平方探测法实现

### 0x00 初始化散列表

![TIM截图20200217125503](/assets/img/TIM截图20200217125503.png)

​		这里需要注意的是 如果散列表大小太小，不如不用散列表直接数组遍历查找

​		![TIM截图20200217125721](/assets/img/TIM截图20200217125721.png)

注意 删除元素的时候不能把元素所在的位置直接置空，应该有一种状态来表示已删除，因为如果直接置空，则查找的时候，本来元素应该可能在后面，但是由于删除了提前遇到空位，所以直接返回查找失败了，如果有一个表示已删除的状态，那么查找还可以继续下去，同样的插入则不会受影响。

### 0x01 查找

![TIM截图20200217130444](/assets/img/TIM截图20200217130444.png)

### 0x02 插入

![TIM截图20200217130840](/assets/img/TIM截图20200217130840.png)

### 0x03 双散列探测法

![TIM截图20200217131056](/assets/img/TIM截图20200217131056.png)

hash（key）=（key%p+di %p  ，di=i*hash2（key）， hash2（key）=p-key%p   其中p<tablesize  p和tablesize都是素数

### 0x04 再散列rehashing

​		当装填因子过大的时候（也就是散列表快满的时候），查找的效率必然会降低，因为冲突碰撞增大，所以为了解决这个问题，当状态因子过大的时候，我们必须扩大tablesize，同时**对所有元素重新插入（重新计算位置）**。实用的装填因子0.5<=a<=0.85