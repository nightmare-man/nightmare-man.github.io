---
layout: post
title: tcpip协议复习
subtitle: tcpip协议复习
date: 2023-4-6
author: nightmare-man
tags: 计算机网络
---



> 趣闻：这篇博客本来是4.6号就写好了的，但是7号有个面试，防止面试官提前看到我复习的内容，就没有6号上传，7号下午面试结束才上传的

# 0x00 ip协议

## 	tcp/ip协议栈分：

​	**网络接口层**（物理+数据链路）：负责搭建逻辑链路

​	**网际层**：负责分组转发，选择路由

 	**传输层**：实现端到端的通信

​	**应用层**：高层协议

​	

## 网络层要实现两个功能：

1**路由选择** 根据网络情况，动态选择一条路径 

2**分组转发**根据转发表，将ip数据报从合适的端口转发出去

常见路由算法：**距离向量算法**和**链路状态算法**，前者只与附近节点交换网络上所有主机的距离，超过16不可达到；后者则是与网络上所有节点交换自己附近有哪些节点，所有节点都获得网络拓扑，并用最短路径算法计算路线。

## 常见的概念

**ip地址：**网络层使用的协议是ip协议，ipv4和ipv6两个版本，用ip地址标识主机。ipv4使用32比特位，即256\*256\*256\*256. 由两部分构成：网络号和主机号，使用掩码或者cidr标识，确定网络号的位数。ip地址保留了一些网络号和主机号，例如 127开头为回环表示主机自身，主机号全0表示网络 主机号全1表示广播

**nat转换**：将公网i与内网ip互转，使得对外可以隐藏自己的ip。原理很简单，在拥有公网ip的网关上，建立一张转换表，将公网的ip：端口对映射到内网ip：端口对，不过这种映射一般是临时且动态的。

**arp协议**：数据链路层使用mac地址标识一个数据链路层端口，而ip层使用ip地址，因此需要建立两者之间的映射关系，需要用到arp协议。当协商好了每台主机的ip地址后，其他主机通过ip访问另一台主机的适合，在数据链路层需要找到对应的mac地址，填入到以太网帧的头部。 通常会**使用arp缓存**，减少（arp）询问的次数

**dhcp协议**：给新加入网络的主机自动分配ip地址的协议，新加入的网络主机会发送源地址为0.0.0.0 (还没有确定ip当然是0.0.0.0)目的地址为255.255.255.255的dhcp询问,等dhcp回复。注意**（内网）ip地址是临时分配的**

## 网络层转发的过程：

​	假设现在有一条待发送的ip数据报

①通过路由协议建立路由表  **<目的网络，下一跳ip地址>**

②通过路由表匹配ip数据报目的地址的网络号与路由表项的网络号，如没找到使用**默认路由**

③发送到对应的ip地址（注意ip源地址和目的地址均不改变，数据链路层的mac源地址和目的地址改变，因为数据链路层对网络层透明，所以网络层并不需要什么操作）

## ipv4分组详解

​	**分片：**数据链路层设置了mtu，以太网帧最大长度受到限制，因此ip数据报的长度也会收到限制，ip数据报长度超过mtu时，就会进行分片，分成若干个ip分片，通过首部的**标识**区分是不是一个ip数据报，而**片偏移和标志**分别记录数据相较于开始的偏移和是否还有后续分片。**不同链路mtu不同，因此需要分片**

​	**生存时间ttl**：数据报在网络中可通过的最大路由数量，**防止一直在网络中循环**，每经过一个路由就ttl减1.

## ipv6

​	ipv6增加了地址位数，解决了地址紧缺问题；都是公网ip，不再需要nat；不再在网络层进行分片。

## ICMP协议

​	网络层的链路状态检测协议，分为两类，**ICMP差错报文和ICMP询问报文**，**ping命令就是利用了ICMP询问报文，而trace则用了ICMP差错报文（ttl从0不断增大，收到时ttl为0的路由器会发送差错报文给源主机，借此可以找到路径上的所有路由）**

# 0x01 TCP/UDP协议

​	传输层提供端到端的数据传输服务，即进程到进程。通过ip地址：端口号，来唯一标识一个端。端口号是通信双方主机分配的。**0-1023端口都被保留给常见协议 ** ssh22 http 80 **ip地址+端口又称套接字**

## tcp协议

​	tcp是一种**有连接**的**可靠**的**字节流协议**

​	**有连接**：传输数据前必须建立连接，传输完成后需要释放连接。

​	**可靠**：保证无差错，不重复，有序。为了实现可靠，采用三个机制：

​	①**确认机制**：发送方每发送一个tcp数据报，接收方必须回复一个确认，（冗余确认，期望收到1但是收到了345，则对234都发送ACK 1）

​	②**超时重传机制** 如果指定时间内没有收到确认，发送方会再次发送

​	③**缓存**：不论是发送放还是接收方，**都有两个缓冲区，接收缓冲区和发送缓冲区**，用于**重传和排序**

## tcp连接建立与终止

​	**建立**

​	①a->b SYN  客户端给服务器发送syn报文，  客户端发送后处于 **SYN SNET状态**

​	②b->a SYN ACK  服务器对于客户端发送的报文进行确认， 服务器端发送确认后处于 **SYN RECVD**状态

​	③a->b 发送ACK 对该确认进行确认，**这样服务器才能知道客户端能够收到自己的消息**  双发都处于**ESTABLISHED状态** 

​	没有第三次握手①则服务器端不知道客户端能否收到自己的消息，比如客户端很久之前发送的SYN请求，服务器端没收到，但是当客户端已经终止后，服务器端又收到了，那此时服务器发送SYN ACK就能建立连接，但显然，事实上无法传输数据 ②需要在连接时交换双方起始的seq号（序列号）

​	**终止**

​	①a->b FIN a发送后处于**FIN WAIT1** ，此时a处于半关闭状态，不能发送，但是可以读

​	②b->a ACK b发送后处于**CLOSE_WAIT，**此时b也处于半关闭状态，不能读，但是可以送

​	③b->a FIN ACK b处于**LAST_ACK**状态，b读写均关闭

​	④a->b ACK a发送后处于**TIME_WAIT**状态,a在等待两个MSL（最大传输时间）后处于关闭状态，而b在接收到后处于关闭状态。

​	为什么需要四次挥手，a给b发的FIN只是单方面的想关闭，b可能还需要发送数据。所以两次FIN 两次ACK。a对b发送的FIN ACK 进行ACK后为什么要等两个MSL？防止最后的ACKb没收到,应对b的超时重传，再次ACK

## TCP流量控制和拥塞控制

​	前者指的是，**防止接收方缓存不及时**，爆缓存，因而**对滑动窗口大小进行控制**；后者指的是**防止链路过载**，因而对**滑动窗口大小进行控制**。 因此我们可以得知 **实际窗口大小= min（RWND，CWND）** （receive window,crownd）。

​	流量控制：接收方会在确认报文的首部 窗口字段，将rwnd通知给发送方。

​	拥塞控制：通过估算不断调整的CWND。

​	拥塞控制的4种算法 ：

​	**①慢开始**，并非指增长速度慢，而是指CWND每次都从1开始，然后每发送1个数据报CWND翻一倍，直到达到门限。开始执行拥塞避免算法。

​	**②拥塞避免**，每次发送一个数据报后窗口后CWND+1 而不是翻倍，**也就是大于门限就+1 小于就翻倍。**

​	不论是慢开始阶段还是拥塞避免阶段，**发送方都会检测拥塞，一旦检测到了，门限就设置为此时CWND的一半**，**同时CWND置1！！！**

​	**③快重传**  基于之前的冗余确认机制，如果发送序号1，但是接收方没收到，又发送了234，那么接收方会ack 1三次，等待重传1，**此时发送方不必等序号1的定时到达，而可以直接重传**，**因为连续收到三个重复的ack 表明链路应该不是那么拥塞。**

​	**④快恢复**，如果发生拥塞后出现了快重传（连续收到三个重复的ACK），那么**门限设置为CNWD一半，但是CWND也只是减半**，然后执行拥塞避免，**CWND不是从1开始，所以称为快恢复**。

## 	UDP协议

​	UDP是无连接的，基于报文的。

​	UDP首部比较小，没有那么多约束，**效率高**，**没有缓存**，**对于应用层交付的数据，不处理不拆分**（**但是网络层可能会ip分组**）

# 0x02 用户层协议

## 	DNS

​	为了便于记忆，用主机名代替ip地址，而主机又属于不同的域，又称域名。域名是有层次的，例如下列的

​	www.baidu.com www是三级域名，baidu是二级域名，com是顶级域名。三级域名分别由不同机构管理,

www是由百度公司管理 baidu这个域名是由互联网机构管理， com是由顶级机构管理。

​	**域名解析被设计成分布式的**，一共有四级服务器参与：**根域名服务器，顶级域名服务器，权限域名服务器，本地域名服务器**。 比如你设置dns为8.8.8.8时，是设置本地域名服务器，查询www.baidu.com 时，查询www需要在权限域名服务器。

​	**域名解析的过程**：

​	首先需要知道的是，**不论是各级dns服务器还是请求的主机自己都有dns缓存**，如果一个域名被缓存，这不需要继续查询。以下讨论未找到缓存时。

​	①主机向**本地dns服务器**发出查询，如果本地dns缓存了那就直接返回给主机

​	②如果**本地dns服务器**不知道，那就由**本地dns服务器依次查询根域名服务器，顶级域名服务器，和权限域名服务器**，分别得到每一级域名储存在哪个域名服务器，最终在对应的权限域名服务器查询到ip地址（从根域名服务器查com顶级域名对应哪个顶级域名服务器，然后从顶级域名服务器查询baidu这个二级域名对应哪个权限域名服务器，实际上就是百度公司的服务器，然后从权限域名服务器找到www对应哪个ip）

​	③本地域名服务器返回给主机

## 	HTTP

​	http是一种超文本协议，由客户端请求，服务器应答，**是无状态的**。（因此用cookie和session保持状态，**cookie是包含在请求头和相应头里的一个字段，而session是服务器为每一个连接保存的状态。**）

​	http请求分为请求头，消息体两部分  ，常见请求类型有**get** **post** **head**（单纯获取响应头） **delete**（删除某个资源）

​	http原本是tcp连接建立后只能传1个请求和应答，就关闭，后面可在请求头种加入keep-alive传输多个请求和应答。

# 0x03 网络安全

## 	非对称加密

​	公钥公开，私钥自己保存，**一方加密的数据，只能用另一方解密**（即两者都可以用来加密解密）

## 	数字证书

​	包含两部分，都是被ca私钥加密的

​	①申请信息  包含该待鉴权机构的公钥，url，申请时间，有效时间等，摘要算法

​	②数字签名  ca对申请信息进行摘要得到数字签名

​	验证的时候，服务器发过来他的证书，客户端用ca的公钥解密，并用同样的摘要算法对申请信息进行摘要，与数字签名比较，相同则说明证书未被串改，**但是这只说明一件事，那就是这个证书是有效的，未被篡改的，**，是不是这个网站的呢？还需要比较url，并用**证书里的公钥加密**发送数据看看服务能不能解密。

##  	HTTPS

​	客服端请求证书，验证证书后，用公钥加密一个对称加密的密钥，然后双发用这个密钥开始传输数据