---
layout: post
title: 汇编语言笔记17使用BIOS进行键盘输入和磁盘读写
subtitle: 汇编语言笔记17使用BIOS进行键盘输入和磁盘读写
date: 2020-06-10
author: nightmare-man
tags: 8086汇编
---

# 汇编语言笔记17使用BIOS进行键盘输入和磁盘读写

### 0x00 int9中断例程对键盘输入的处理

​		键盘输入将引发9号中断，BIOS提供int9中断例程。cpu在9号中断发生后，执行int9中断例程，从60h端口读出扫描码，并将其转化成相应的ascii码或状态信息，储存在内存的指定空间（键盘缓冲区或状态字节）中

​		一般的键盘输入，在执行完int9中断例程后，都放在了键盘缓冲区中。键盘缓冲区是一个大小为16字节的环形队列，可以存储15个按键的扫描码和对应的ascii码。

​		![QQ截图20200610092415](/assets/img/QQ截图20200610092415.png)

![QQ截图20200610092510](/assets/img/QQ截图20200610092510.png)

![QQ截图20200610092544](/assets/img/QQ截图20200610092544.png)

​		从上面可以看出 int9中断例例程会不断的向队列里加入一般按键的扫描码和对应的ascii码放在队列尾部



### 0x01 使用int 16h中断例程读取键盘缓冲区

​		如果int9中断一直向缓冲区写入，那缓冲区一直是满的，所以有读取并删除缓冲区队列尾部的int 16h中断例程，该功能的编号为0.

​		**mov ah,0 int 16h 结果 ah=扫描码  al=ascii码**

![QQ截图20200610092942](/assets/img/QQ截图20200610092942.png)

![QQ截图20200610093011](/assets/img/QQ截图20200610093011.png)

![QQ截图20200610093039](/assets/img/QQ截图20200610093039.png)

​		如图上所说，调用一次int 16h的0号功能，便从缓冲区尾部读取并删除一个纪律，如果没有，那么会一直等待新的按键记录写入缓冲区 再读取删除，那么int 16的中断例程的0号功能里，必然没有屏蔽外设的中断，说明IF被置1了（之前进入int 16被硬件自动置0了）

![QQ截图20200610093422](/assets/img/QQ截图20200610093422.png)

![QQ截图20200610093722](/assets/img/QQ截图20200610093722.png)

```assembly
assume cs:code
code segment
start:	mov ah,0
		int 16h
		
		mov ah,1
		cmp,al,'r'
		je red
		cmp al,'g'
		je green
		cmp al,'b'
		je blue
		jmp short sret
red:	shr ah,1
green:	shr ah,1
blue:	mov bx,0b800h
		mov es,bx
		mov bx,1
		mov cx,2000
s:		and byte ptr es:[bx],11111000b
		or es:[bx],ah
		add bx,2
		loop s
sret:	mov ax,4c00h
		int 21h
code ends
end start
```

![QQ截图20200610094823](/assets/img/QQ截图20200610094823.png)

​		上述代码运行正确，利用比较和跳转巧妙的让不同输入执行不同的shl次数，让ah刚好是前景颜色

![QQ截图20200610094958](/assets/img/QQ截图20200610094958.png)

​		这个说法是对的，因为进入int 16 的过程中if tf都被设置为0，然而如果缓冲区没有记录可以读取了，int 16会等待新的记录进入，也就是说int 16中还可以响应int9中断例程，所以IF必然要被置1



### 0x02 字符串的输入

​		最基本的字符串输入程序，需要具备下面的功能。

​		（1）在输入的同时显示这个字符串

​		（2）一般在输入回车符后，输入结束

​		（3）可以删除已经输入的字符

![QQ截图20200610102003](/assets/img/QQ截图20200610102003.png)

```assembly
assume cs:code,ds:data
data segment
		db 128 dup (0)
data ends
code segment
start:	mov ax,data
		mov ds,ax
		mov si,0
		mov dh,14
		mov dl,40
		call input_str
		mov ax,4c00h
		int 21h

input_str:	jmp in_start
			top dw 0;栈顶 也就是最后一个字符 
in_start:	push ax
			push bx
			push cx
			push es
			push di
			mov ax,0b800h
			mov es,ax
			mov al,160
			mul dh
			add dl,dl
			mov dh,0
			add ax,dx
			mov di,ax;di指向第一个字符要显示的位置
typing:		mov ah,0
			int 16h;ah扫描码，alascii码
			cmp al,20h
			jb not_show;小于20h不显示
			mov bx,top
			mov ds:[si+bx],al
			add bx,bx
			mov es:[di+bx],al
			mov byte ptr es:[di+bx+1],2
			inc top
			jmp short typing
not_show:	cmp al,8;看是不是退格
			jne fin
			cmp top,0;
			je short typing;如果当前没有字符就不继续退了
			dec top
			mov bx,top
			mov byte ptr ds:[si+bx],0
			add bx,bx
			mov byte ptr es:[di+bx],0
			mov byte ptr es:[di+bx+1],0
			jmp short typing
fin:		cmp ah,1ch; 这次用的是扫描码而不是ascii 因为按下回车键后的ascii是个很神奇的东西
			jne short typing
			mov bx,top
			mov byte ptr ds:[si+bx],0;以0结尾的字符串
			pop di
			pop es
			pop cx
			pop bx
			pop ax
			ret
code ends
end start
```

![QQ截图20200610110113](/assets/img/QQ截图20200610110113.png)

​		上述代码运行正确，但是和书上给的代码写法不一样，主要是我没有进行更细的子程序划分



### 0x03 应用int13h中断例程对磁盘读写

​		额 这个部分就算了吧，只是一个int 13h 的简单例程，没有更多深入知识，关键是这个例子用的是软盘，还说读写硬盘很危险，但是2020年了我哪儿去找软盘，何况是dosbox也不知道能不能识别软盘，就简短的放上书中原文吧：

![QQ截图20200610110744](/assets/img/QQ截图20200610110744.png)

![QQ截图20200610110755](/assets/img/QQ截图20200610110755.png)

![QQ截图20200610110806](/assets/img/QQ截图20200610110806.png)

![QQ截图20200610110822](/assets/img/QQ截图20200610110822.png)

