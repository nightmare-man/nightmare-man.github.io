---
layout: post
title: 算法-动态规划
subtitle: 算法-动态规划
date: 2020-02-29
author: nightmare-man
tags: 数据结构与算法
---
# 算法-动态规划

### 0x00 什么是动态规划（dynamic programming）

​		自己水平有限，推荐一个连接，什么是[动态规划-漫画](https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653190796&idx=1&sn=2bf42e5783f3efd03bfb0ecd3cbbc380&chksm=8c990856bbee8140055c3429f59c8f46dc05be20b859f00fe8168efe1e6a954fdc5cfc7246b0&scene=21#wechat_redirect)

​		以题目为例子

> 一个10级的台阶，每次只能一步一步上或者两步两步上，有多少种走法

​		动态规划有三个点：

​		1**最优化子结构**	当前状态 是又前一步的那几种状态 如何选取 进而转换来的 ，我们把n层台阶的走法和记为f(n)，那么：f(10)=f(8)+f(9) 其中的 f(8)+f(9)即为最优子结构。

​		2**状态转移方程**	f(n)=f(n-1)+f(n-2)即为我们的状态转移方程，且n>2  f(1)=1 f(2)=2 后面的是边界

​		3**无后效性**	 有两层含义，第一层含义是，在推导后面阶段状态的时候，我们只关心前面阶段的状态值，不关心这个状态是怎么一步步推导出来的。第二层含义是，某阶段状态一旦确定，就不受之后阶段的决策影响。无后效性是一个非常“宽松”的要求。只要满足前面提到的动态规划问题模型，其实基本上都会满足无后效性。 

### 0x01 如何做题

​		动态规划做题最重要的是如何找到**状态转移方程**，很多时候并不是一眼就能看出，所以需要我们画图来描述问题，下面以背包问题举例：

​		**[01背包问题](https://www.luogu.com.cn/problem/P1060)**

> 金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间他自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过N元钱就行”。今天一早金明就开始做预算，但是他想买的东西太多了有M个，肯定会超过妈妈限定的N元。于是，他把每件物品规定了一个重要度，分为5等：用整数1-5表示，第5等最重要。他还从因特网上查到了每件物品的价格（都是整数元）。他希望在不超过N元（可以等于N元）的前提下，使每件物品的价格与重要度的乘积的总和最大。
>
> 设第j件物品的价格为v[j]，重要度为w[j]，共选中了k件物品，编号依次为j1,j2,...jk则所求的总和为：
>
>  v[j1]×w[j1]+v[j2]×w[j2]+…+v[jk]×w[jk]。 
>
> 请你帮助金明设计一个满足要求的购物单。

​		之所以称为"01背包"，是因为每件物品只有**选**或者**不选**两种情况。

​		这个问题的最优子结构是什么呢？我们把m个物品编号1，2，..m。每个物品的价格为c[i],价值为v[i]，**只有n元从m个商品中买的价格重要度乘积和最大，设为f(n,m)**，那实际上

​		**①f(n,m)=max(f(n,m-1)，f(n-c[m],m-1)+c[m]*v[m])**（n>=c[m]）;

​		**②f(n,m)=f(n,m-1)**（n<c[m]）;

​		**③f(n,1)=c[1]*v[1]**  (n>=c[1]);

​		**④f(n,1)=0**   (n<c[1]);

​		也就是最优子结构是:第m个物品买或者不买两种情况中的最大值。

​		注意在该问题中我先给出了状态转移方程，再说的最优化子结构，实际过程中是先想最优化子结构，一半是画流程图。

​		有了状态转移方程，很容易想到用递归实现，递归实现 是一个树状的 图形，树高为m，所以时间复杂度2^m 是一个指数 空间复杂度也是2^m 实际上 我们通过观察树的节点，发现很多节点的状态是重复的，我们可以用一个二位数组ans来保存对应的m n时的最大值，这样可以消除重复的节点，时间复杂度为n 空间复杂度m*n。但是空间复杂度还能降低。

​		注意到我们最终结果都是保存在二维数组ans里，因为有两个变量，但实际上，我们是以m为轴 一层一层的往后推进的，实际上只用一个长度为n的一维数组来保存上一层的值和当前这一层的值就行了

```c
int i,k;
int last[n],now[n];
for(i=1;i<=m;i++){
    for(j=1;j<=n;j++){
        if(j>=c[i]){
            now[j]=max(last[j],last[j-c[i]]+c[i]*v[i]);//买的起就买或者不买选最大的情况
        }else{
            now[j]=last[j];//买不起就是上一层一样的情况
        }
    }
    //进行下一层,当前的now变成last了，所以值要放在last里
    for(j=1;j<=m;j++){
    	last[j]=now[j];
    }
}
```



​		**完全背包问题**

​		完全背包是每个物品可以不限次数的买，那么如果将上面那个题改成完全背包,那么上面的状态转移方程①应该变为：

​		**①f(n,m)=max(f(n,m-1)，f(n-c[m],m)+c[m]*v[m])**（n>=c[m]）;

​		原因在于对于第m个物品，我们有 买不起 买的起两种情况，上述方程是买得起的情况，但是买得起又分为买一个 两个 三个..... ，我们不可能一一列举出来,而我们只需要把买了一个m这种情况算出来之后，继续在这种情况下看再买一个m的情况是多少，一直到买不起m才把m这一层所有情况分析完，所以要把m-1改成还是m

​		**多重背包问题**

​		**恰好背包问题**

​		**分组背包问题**

​		**恰好背包问题**