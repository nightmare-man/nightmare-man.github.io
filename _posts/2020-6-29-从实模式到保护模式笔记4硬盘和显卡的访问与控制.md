---
layout: post
title: 从实模式到保护模式笔记4硬盘和显卡的访问与控制
subtitle: 从实模式到保护模式笔记4硬盘和显卡的访问与控制
date: 2020-06-29
author: nightmare-man
tags: x86汇编
---
# 从实模式到保护模式笔记4硬盘和显卡的访问与控制

### 0x00 代码

​	用户程序代码，用来显示一堆字符的：

```assembly
SECTION header vstart=0	;定义用户程序头部段 假定起始位置偏移地址为0
program_length dd program_end;program_end是一个标号、偏移地址
code_entry dw start;start的偏移地址
dd section.code_1.start;段地址，mbr加载器会从这两个地方读地址并跳转。
realloc_tbl_len dw (header_end-code_1_segment)/4;用来计算段重定位
;表的个数[不写死，方便修改]

code_1_segment dd section.code_1.start
code_2_segment dd section.code_2.start
data_1_segment dd section.data_1.start
data_2_segment dd section.data_2.start
stack_segment dd section.stack.start

header_end:

;=============================================================
SECTION code_1 align=16 vstart=0;定义代码段1 16字节对齐
put_string:
mov cl,[bx]
or cl,cl;判断cl是不是等于0
jz .exit
call put_char
inc bx
jmp put_string

.exit:
ret
;---------------------------------------
put_char:
push ax
push bx
push cx
push dx
push ds
push es

;以下取光标位置
mov dx,0x3d4
mov al,0x0e
out dx,al
mov dx,0x3d5
in al,dx
mov ah,al;光标地址的低8位

mov dx,0x3d4
mov al,0x0f
out dx,al
mov dx,0x3d5
in al,dx;光标地址的高8位
mov bx,ax;bx即代表光标位置的16为数

cmp cl,0x0d;看看是不是回车符
jnz .put_0a
mov ax,bx
mov bl,80
div bl
mul bl
mov bx,ax;bx变成了当前行的首列的地址,回车的作用
jmp .set_cursor

.put_0a:
cmp cl,0x0a
jnz .put_other;不是换行就正常显示
add bx,80
jmp .roll_screen

.put_other:
mov ax,0xb800
mov es,ax
shl bx,1;bx=bx*2
mov [es:bx],cl
;推进光标
shr bx,1
add bx,1

.roll_screen:
cmp bx,2000;光标超出当前屏幕？滚屏
jb .set_cursor;不超过就直接设置新光标

mov ax,0xb800
mov ds,ax
mov es,ax
cld
mov si,0xa0
mov di,0x00
mov cx,1920
rep movsw
mov bx,3840
mov cx,80
.cls:
mov word [es:bx],0x0720;空白
add bx,2
loop .cls
mov bx,1920;重新置光标

.set_cursor:
mov dx,0x3d4
mov al,0x0e
out dx,al
mov dx,0x3d5
mov al,bh
out dx,al
mov dx,0x3d4
mov al,0x0f
out dx,al
mov dx,0x3d5
mov al,bl
out dx,al

pop es
pop ds
pop dx
pop cx
pop bx
pop ax
ret
;-------------------------------------------------------------
start:
mov ax,[stack_segment]
mov ss,ax
mov sp,stack_end

mov ax,[data_1_segment]
mov ds,ax

mov bx,msg0
call put_string;显示第一段信息

push word [es:code_2_segment]
mov ax,begin
push ax
retf;结合push实现跳转

continue:
mov ax,[es:data_2_segment]
mov ds,ax

mov bx,msg1
call put_string
jmp $
;=============================================================
SECTION code_2 align=16 vstart=0 ;代码段2
begin:
push word [es:code_1_segment]
mov ax,continue
push ax
retf;又跳回去。。。。啥都没干的代码段2

;=============================================================
SECTION data_1 align=16 vstart=0
msg0 db 'This is NASM - the famous Netwide Assembler!'
db 'Back at SourceForge and in intensive development!'
db 'Get the current versions from http://www.nasm.us/.'
db 0x0d,0x0a,0x0d,0x0a;换行回车两次
db 'Example code for calculate 1+2+...+1000:',0x0d,0x0a,0x0d,0x0a
db '     xor dx,dx',0x0d,0x0a
db '     xor ax,ax',0x0d,0x0a
db '     xor cx,cx',0x0d,0x0a
db '  @@:',0x0d,0x0a
db '     inc cx',0x0d,0x0a
db '     add ax,cx',0x0d,0x0a
db '     adc dx,0',0x0d,0x0a
db '     inc cx',0x0d,0x0a
db '     cmp cx,1000',0x0d,0x0a
db '     jle @@',0x0d,0x0a
db '     ... ...(Some other codes)',0x0d,0x0a,0x0d,0x0a
db 0;结束符eol
;=============================================================
SECTION data_2 align=16 vstart=0
msg1 db 'The above contents is written by nightmare-man.'
db '2020-6-29'
db 0

;=============================================================
SECTION stack align=16 vstart=0
resb 256
stack_end:
;=============================================================
SECTION trail align=16;trail 尾巴
program_end:
```

​	mbr扇区引导代码：

```assembly
app_lba_start equ 100 ;声明常数，用户程序起始逻辑扇区号
SECTION mbr align=16 vstart=0x7c00;偏移地址假定为0x7c00 这样汇编地址
;就从0x7c00开始
mov ax,0
mov ss,ax
mov sp,ax

mov ax,[cs:phy_base]
mov dx,[cs:phy_base+0x02]
mov bx,16
div bx
mov ds,ax
mov es,ax;用于计算加载用户程序的逻辑 段地址

;以下为读取程序的起始部分
xor di,di
mov si,app_lba_start
xor bx,bx
call read_hard_disk_0

;以下判断剩下的程序有多大
mov dx,[2];0
mov ax,[0];ax读取了用户程序的结束的汇编地址program_end
mov bx,512
div bx
cmp dx,0
jnz @1;未除尽，因此实际扇区还要多一个
dec ax;因为前面已经读了一个扇区，再读的话少读一个就行
@1:
cmp ax,0
jz direct;如果剩下的不足512字节
push ds
mov cx,ax
@2:
mov ax,ds
add ax,0x20
mov ds,ax;修改段地址,准备读入扇区到指定段地址

xor bx,bx;每次读入时，偏移地址始终为0
inc si
call read_hard_disk_0
loop @2

pop ds;恢复数据段基址到用户程序头部段

;计算入口点代码段基址
direct:
mov dx,[0x08]
mov ax,[0x06];dx ax分别是用户程序code1段的段基址的高16位和低16位
call calc_segment_base
mov [0x06],ax;回填修正后的code1段地址

;开始处理段重定位表
mov cx,[0x0a];需要重定位的项目数量
mov bx,0x0c;重定位表首地址

realloc:
mov dx,[bx+0x02];高16位
mov ax,[bx];低16位
call calc_segment_base
mov [bx],ax;回填段基址
add bx,4;下一个重定位项目
loop realloc

jmp far [0x04]
;-----------------------------------------------------------
read_hard_disk_0:;输入di si分别位逻辑扇区的高16位和低16位 ds:bx
;是读入地址
push ax
push bx
push cx
push dx
mov dx,0x1f2
mov al,1
out dx,al

inc dx
mov ax,si
out dx,al

inc dx
mov al,ah
out dx,al

inc dx
mov ax,di
out dx,al

inc dx
mov al,0xe0
or al,ah
out dx,al

inc dx
mov al,0x20
out dx,al

.waits:
in al,dx
and al,0x88
cmp al,0x08
jnz .waits

mov cx,256
mov dx,0x1f0

.readw:
in ax,dx
mov [bx],ax
add bx,2
loop .readw

pop dx
pop cx
pop bx
pop ax
ret

;---------------------------------------------
calc_segment_base:;计算16位段地址 dx:ax分别是高16位低16位物理地址
;返回ax 16位段基地址
push dx
add ax,[cs:phy_base]
adc dx,[cs:phy_base+0x02]
shr ax,4
ror dx,4;带借位的右位移
and dx,0xf000
or ax,dx

pop dx
ret
;---------------------------------------------------
phy_base dd 0x10000 ;用户程序被加载的物理起始地址
times 510-($-$$) db 0
db 0x55,0xaa
```

![QQ截图20200629101144](/assets/img/QQ截图20200629101144.png)

​	以上代码运行正确