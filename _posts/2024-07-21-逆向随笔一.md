---
layout: post
title: 逆向随笔一
subtitle: 逆向随笔一
date: 2024-07-21
author: nightmare-man
tags: 逆向与安全

---

# 一.计算机组成原理：

## 1调用约定

最基础的是__ccall,调用函数前往堆栈，从右向左push，调用完成后，调用者平衡堆栈。

微软x64的四寄存器fastcall,调用者通过rcx rdx r8 r9传递参数，同时在调用前分配“影子储存”，让被调用者，将这几个寄存器放在保存在里面。调用结束后，调用者清理堆栈，好处是。被调用者访问参数更快。

## 2缓冲区溢出检测手段

编译器自动在栈缓冲区和返回地址之间设置一个cookie,返回之前检测cookie是否还在，如果不在，则终止

## 3变长栈帧的实现

一般来说每个函数的栈大小是确定的，但是如果使用了类似alloca这种从栈分配的，就不确定了。返回时收缩栈帧的办法是，函数开始时保存rsp到rbp，然后返回时恢复回来

## 4PE和COFF格式

一句话 PE是COFF的扩展。PE文件结构框架如下：

![QQ_1721443754523](/assets/img/QQ_1721443754523.png)

对于PE文件，我们关注什么？

1首先，PE文件特征，出现'P','E',0,0几个字节即可认定位疑似PE文件，字节位置即位PE文件头位置。

2有关的平台和文件类型，都在IMAGE_FILE_HEADER，还有很大一部分信息，在IMAGE_OPTIONAL_HEADER中，这个结构大小是可变的，在FILE_HEADER中有字段表明大小。

3PE文件的实体资源是各种section,比如代码，静态数据，导入，导出，重定向，资源等。而在 PE header和section中间，有个section table,就是用来描述各个section的信息的。

4一些常见的section,以及section之间的合并：

```c
.text;//代码区块，全是指令
.data;//全局变量和静态变量，初始化就有值，未初始化0覆盖
.rdata;//只读数据块，很少用到
.idata;//输入表，外来的dll和数据信息，一般将idata合并到.data里
.edata;//输出表，创建的api和外部数据，也会在release模式下合并到.data里
.rsrc;//资源
.reloc;//基地址重定位表，一般只有dll需要
```

[^__declspec(dllexport)]: 写dll的时候，要将函数提供给export出来给其他可执行程序使用，需要使用\_\_declspec(dllexport),这个声明意味着，将会在PE export table中增加一条跟导出对象有关的条目（可以是函数或者变量）。同样的在引用的时候，需要加上\_\_declspec(dllimport),在import table中增加一个条目。
[^extern]:  这个模块之间的导入导出，和多个obj文件之间的导入导出不同，那个是COFF格式，利用的是符号表，只需要简单一个extern就可以引用，被引用的是一个全局变量就够了。对于函数只需要有其声明就可以用，原因是，这是编译时的链接，符号信息还在。



[^extern c]: extern "c" 用在c++里，表明将函数以c语言的形式声明，这个的用途是什么，c语言obj引用c++ obj函数的时候，c语言中的符号名（不论是在导入表，导出表还是符号表），都是干净无前缀后缀的，但c++是不一样的，因此需要加上extern c，以c语言形式声明。 这个和前面的\_\_declspec(dllexport)可以结合使用



5根据PE格式理解导入和导出：

先看导出表，导出表包含了所有要导出函数的名字和对应的RVA。因此，当一个dll装载时，想要获取某个函数的地址，只需要根据名字匹配，找到对应的RVA，再加上模块基地址，即可得到函数的va；

再看导入表，导入表里针对每个要导入的模块有个条目，这个条目里又包含该模块所有要导入函数的名字，和地址，当然一开始的时候这个地址是假的，当装载了要导入的模块后，由装载器重新填写正确的地址。

​	导入外部模块函数时，会使用call [iat entry fun addr]这种形式,称为IAT间接调用。

​	另外有一个很类似的东西时**“incremental link”**,他会利用jmp table 间接调用函数。 先call 到jmp table的某个条目， 然后jmp到真正函数。这么做的目的是为了实现增量编译，不至于修改一点代码就要重新全部编译。

6根据PE格式理解重定向：

首先，一般只有动态库需要重定向。一开始的时候，dll内部有很多对自身模块内地址的引用，（如果是对其他模块符号的引用，则关注导入表即可）。这些地址在编译时都是按照默认的基地址写的。但是有可能装载的时候原来的基地址已经有模块加载了，这个时候就需要重定向了。需要将所有原来那些模块内部的绝对地址的地方都加一个偏移（实际装载地址-默认装载基地址）。因此，编译的时候对于这种绝对基地址，都在reloc节记载了一个条目，这个条目记载了要修改的rva，只需要遍历所有条目，都修改了就ok了。

7 tls回调函数

tls是thread local storage, 在这里创建变量，每个线程都会有一个副本。而tls回调函数，会在特定的时候调用，比如

```c
void NTAPI tls_callback(PVOID DllHandle, DWORD dwReason, PVOID)
{
    if (dwReason == DLL_THREAD_ATTACH)
    {
        MessageBox(0, L"DLL_THREAD_ATTACH", L"DLL_THREAD_ATTACH", 0);
    }
  
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        MessageBox(0, L"DLL_PROCESS_ATTACH", L"DLL_PROCESS_ATTACH", 0);
    }
}
```

如何利用这个来反外挂呢？可以在tls callback的thread_attach里，检查当前线程的起始地址，判断这个地址在哪个模块，是不是被注入的模块。



## 5链接

链接的出现是为了解决单独编译，使得模块化代码成为可能。

链接可以在编译的时候，分开编译最后连接在一起。也可以是程序运行时链接，也可是运行中动态链接。



# 二.Windows内核

### 1用户态内核态通信（函数调用）

​	用户层代码，先调用windows api，这些api都在某些单独dll里，比如user32.dll ws2.dll，这些dll又调用windows子系统dll ntdll.dll。ntdll.dll 通过syscall/sysenter指令，进入内核态，从ssdt里（system service dispatch table）中找到对应的同名内核函数，执行完后返回用户态，进而返回到最初调用点。

​	通过挂钩ssdt里面函数的地址，来实现对所有系统调用的监控，windows子系统（带窗口）有关的系统调用在另一张表里，称为shadow ssdt.

### 2内核里的函数调用

​	内核态调用函数时，要注意某些函数的irql（interrput request level）,过高的irql，会导致不会切换线程，如果有对某些对象的等待，可能会死锁。内核函数按照开头可以区分功能。

### 3对象和对象管理器

​	windows设计的时候采用了面向对象的思想，将一些数据封装起来，用预定义的操作来管理它们，成为对象。并且给对象名称，让其能够像文件那样管理，可以使用winobj查看：

![QQ_1721467717035](/assets/img/QQ_1721467717035.png)

​	对象只能在内核中访问操作，用户态如果要获取，只能够以句柄（已经打开的内核对象的索引）的形式访问。还是由内核函数在操作。

### 4 进程和线程

​	内核里有关进程和线程的结构有两套，一套是KPROCESS KTHREAD,另外一套是EPROCESS ETHREAD,前者K开头，Kernel,是内核的实现部分所使用的对象，后者是E开头，executive，是管理(决策层)进程线程的结构。

​	而在用户态，也有与进程和线程有关的对象，分别是PEB 和TEB。

​	上述这些进程和线程对象，都是互指的，进程会指向拥有的线程链，线程会执行所属的进程。

​	先看用户态，PEB中有个字段是BeingDebugged,在内核中还有其他很多有关调试的信息，比如debugport等，这些都是用来检测调试用的。怎么访问TEB，通过NTCurrentTeb就行，或者通过FS[18h]， FS[0]总是指向一个TiB结构。

​	peb (process environment block)



# 三.异常

异常和中断都由idt里的门调用处理，有的是陷阱门，有的是中断门，陷阱门和中断门的区别是后者不清除IF标志，表明正在处理中断，除非优先级IRL更高的中断。

中断和异常的区别是，前者是异步的，不可预知，后者是同步的，与当前指令有关的。

对于异常处理，除了idt里的硬件自动传递的异常类型号之外，内核定义相关结构，

```c
struct exception_record{
    NTSTATUS exceptioncode;
    PVOID ExceptionAddress;
}
struct trap_frame{
    各种寄存器
}
```

前者用来记录异常的信息，后者用来保存异常产生时的上下文，便于处理。

在构造好了异常相关的结构后，就是把异常送给谁处理了。

在处理异常之前，我们首先得知道，对于每个异常，内核都是期待有一个处理结果的，处理了或者未处理。

通过异常发生时的cs寄存器判断cpl，①如果是内核模式异常，先看有没有内核调试器，有的话发送到调试器，等待它处理。如果不存在调试器，或者调试器返回未处理，则将异常发往内核seh 函数处理表。如果表里没有处理函数，或者处理函数未处理，则蓝屏。

②如果是用户模式，则会有两次机会，两次流程一样，都是先发给内核模式调试器（如果有），再发给用户模式调试器（如果有），再发给用户态dispatch，查找seh 处理函数，如果未找到或者未处理，再一次执行。两次执行完流程还未处理，则中断程序。



这里不得不提一下seh（structed excetpion handler）。它是一种以代码块为单位，用来处理代码块中可能发生的异常的手段。常见如下：

```c
__try{
    may raise exception
}
__except(result or result func){
    do_sth
}
__finally{
    
}//后面这个可要可不要
```

它的工作原理是，当异常被发送到seh处理时。seh查找到**“最近的处理函数”**，发给它处理，如果没有，就是未处理，如果有，这个处理函数做了一些工作，可以返回一个结果给seh，这个结果可以是处理完了，也可以是没处理但是让seh忽略，也可以是没处理让seh继续找。



关于seh怎么找到对应的处理函数，32位windows和64位windows用的方式不同：①前者基于栈帧，每次创建栈帧后开始往seh链表里插入最近的handle，用于处理对应的try里的函数。②后者则是在编译时确定一个section pdata,里面有runtime_func条目，每个条目都是

```c
struct runtime_function{
    pvoid func_start;
    pvoid func_end;
    uwind_info handle_info;
}
```

这个handle info就是对应的函数内是否有处理函数，有的话处理函数在哪儿，相关的展开信息。

[^最近的处理函数]: 在32位seh链表机制下，最近即位链表头，刚插入的handle最近；在64位下，则是handle_info里表明的try的地址范围最接近异常时rip的handle。



为什么不继续用32位下的链表呢？主要是考虑栈里面的数据容易被改动（缓冲区溢出攻击等）。







​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
