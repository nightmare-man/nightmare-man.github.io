---
layout: post
title: 从实模式到保护模式9程序的动态加载和执行
subtitle: 从实模式到保护模式9程序的动态加载和执行
date: 2020-07-07
author: nightmare-man
tags: x86汇编
---
# 从实模式到保护模式9程序的动态加载和执行

### 0x00 代码

​	硬盘主引导扇区代码

```assembly
core_base_address equ 0x00040000 ;常数，内核加载的起始物理地址
core_start_sector equ 0x00000001 ;常数，内核的起始逻辑扇区

mov ax,cs
mov ss,ax
mov sp,0x7c00

;计算GDT所在的逻辑段地址
mov eax,[cs:pgdt+0x7c00+0x02] ;GDT的32位物理地址
xor edx,edx
mov ebx,16
div ebx

mov ds,eax ;GDT所在的逻辑段地址
mov ebx,edx ;段内起始偏移地址

;0#段描述符
mov dword [ebx+0x00],0x00000000
mov dword [ebx+0x04],0x00000000;理论上这两句可以不写

;1#段描述符 数据段4GB 
mov dword [ebx+0x08],0x0000ffff;基地址0x00000000
mov dword [ebx+0x0c],0x00cf9200;粒度为4KB

;2#段描述符 初始化代码段
mov dword [ebx+0x10],0x7c0001ff;基地址0x00007c00
mov dword [ebx+0x14],0x00409800;粒度为1字节 界限为0x1ff也就是大小为512KB

;3#段描述符 堆栈段描述符
mov dword [ebx+0x18],0x7c00fffe;基地址0x00007c00
mov dword [ebx+0x1c],0x00cf9600;粒度4KB 界限 0xffffefff

;4# 显存映射段描述符
mov dword [ebx+0x20],0x80007fff ;基地址0x000b8000
mov dword [ebx+0x24],0x0040920b ;粒度为字节

mov word [cs:pgdt+0x7c00],39 ;描述符表的界限
lgdt [cs:pgdt+0x7c00]

in al,0x92
or al,0000_0010B
out 0x92,al;打开a20

cli;保护模式下中断尚未初始化，先屏蔽

mov eax,cr0
or eax,1
mov cr0,eax
;进入保护模式

jmp dword 0x0010:flush;[16位描述符选择子，32位偏移]

[bits 32]
flush:
mov eax,0x0008;00000000_00001_000,所以选择子的描述符索引是1 是4GB数据段那个（刚好段选择子和对应描述符在GDT内的偏移一样）
mov ds,eax;

mov eax,0x0018
mov ss,eax
xor esp,esp

;加载系统核心程序到内存
mov edi,core_base_address
mov eax,core_start_sector
mov ebx,edi
call read_hard_disk_0;读核心程序的第一个扇区

;判断还剩下多少要读
mov eax,[edi];读核心程序的物理地址处的双字节（因为核心程序在汇编地址0处定义了一个双字节：核心程序的大小）
xor edx,edx
mov ecx,512
div ecx
or edx,edx
jnz @1;如果余数不是0，也就是说 总共有【商+1】个扇区,但是之前读了第一个扇区，还需要读 【商】个扇区
dec eax;减去之前读了一个扇区
@1:
or eax,eax
jz setup;如果商也是0，说明之前一个扇区就读完了，没有剩下的了

;继续读剩下的
mov ecx,eax ;32位下ecx控制loop
mov eax,core_start_sector
inc eax;从下一个逻辑扇区开始接着读

@2:
call read_hard_disk_0
inc eax;只需要手动改变eax，ebx在read_hard_disk_0里会自动+512
loop @2

;读完了就开始设置了
setup:
mov esi,[0x7c00+pgdt+0x02] ;通过4GB数据段访问pgdt的表的物理地址

;建立公用例程段描述符
mov eax,[edi+0x04];edi还是指向核心程序的起始物理地址呢（ds的段基址为0 偏移地址就是物理地址了）[edi+0x04]记录着 公共例程的汇编地址
mov ebx,[edi+0x08];核心数据段汇编地址
sub ebx,eax ;公用例程段的长度
dec ebx;ebx即段界限
add eax,edi ;共用历程段的世界物理地址
mov ecx,0x00409800
call make_gdt_descriptor
mov [esi+0x28],eax
mov [esi+0x2c],edx

;建立核心数据段描述符
mov eax,[edi+0x08]
mov ebx,[edi+0x0c]
sub ebx,eax
dec ebx
add eax,edi
mov ecx,0x00409200
call make_gdt_descriptor
mov [esi+0x30],eax
mov [esi+0x34],edx

;建立核心代码段描述符
mov eax,[edi+0x0c]
mov ebx,[edi+0x00];程序总长度
sub ebx,eax
dec ebx
add eax,edi
mov ecx,0x00409800
call make_gdt_descriptor
mov [esi+0x38],eax
mov [esi+0x3c],edx

mov word [0x7c00+pgdt],63;修改描述符表界限
lgdt [0x7c00+pgdt] ;重新装载
jmp far [edi+0x10] ;保护模式下共读6字节 前4字节是偏移地址 后两字节是 段选择子
;----------------------------------------------------------
read_hard_disk_0:;输入参数 eax 逻辑扇区号 ds:ebx 目标缓冲区地址
push eax		;返回 ebx=ebx+512
push ecx
push edx

push eax
mov dx,0x1f2
mov al,1
out dx,al;写入读取的扇区数

inc dx ;0x1f3
pop eax
out dx,al ;LBA逻辑扇区号 7-0位

inc dx;0x1f4
mov cl,8
shr eax,cl
out dx,al ;15-8

inc dx ;0x1f5
shr eax,cl
out dx,al ;23-16

inc dx;0x1f6
shr eax,cl
or al,0xe0 ; 27-24
out dx,al

inc dx ;0x1f7
mov al,0x20;读命令
out dx,al

.waits:
in al,dx
and al,0x88
cmp al,0x08
jnz .waits ;不忙，且硬盘已经准备好数据传输

mov ecx,256;总共要读的 字 数
mov dx,0x1f0
.readw:
in ax,dx
mov [ebx],ax
add ebx,2
loop .readw

pop edx
pop ecx
pop eax
ret

;----------------------------------------------------------
make_gdt_descriptor: ;输入 eax 线性基地址 ebx 段界限 ecx 属性（各属性都在原始位置 高32位中的对应位置，没有用到的位置就为0） 返回 edx:eax 完整的64位描述符
mov edx,eax
shl eax,16
or ax,bx;构造描述符的低32位

and edx,0xffff0000;获得段界限的高16位
rol edx,8;循环左移  ,但是这导致段界限的高16位 中高8位和低8位的位置反了
bswap edx ;交换成正确的

xor bx,bx;ebx低16位清0
or edx,ebx;装配段界限的高4位

or edx,ecx;装配属性
ret

;----------------------------------------------------------
pgdt dw 0
dd 0x00007e00 ;gdt的物理地址
;----------------------------------------------------------
times 510-($-$$) db 0
db 0x55,0xaa
```

​	内核代码：

```assembly
;以下常量定义。内核的大部分内容都应该固定
core_code_seg_sel equ 0x38 ;内核代码段选择子
core_data_seg_sel equ 0x30 ;内核数据段选择子
sys_routine_seg_sel equ 0x28 ;系统公共例程代码段的选择子
video_ram_seg_sel equ 0x20 ;视频显示缓冲区的段选择子
core_stack_seg_sel equ 0x18 ;内核堆栈段选择子
mem_0_4_gb_seg_sel equ 0x08 ;0-4GB数据段选择子

;==========================================================

SECTION header vstart=0; align=16可省略
core_length dd core_end ;核心程序总长度#00
sys_routine_seg dd section.sys_routine.start;共用历程段位置
core_data_seg dd section.core_data.start;核心数据段位置
core_code_seg dd section.core_code.start;核心代码段位置
core_entry dd start  ;代码入口地址（有效地址）
dw core_code_seg_sel ;核心代码段 选择子

;==========================================================
[bits 32]
SECTION sys_routine vstart=0;系统公共例程段

;----------------------------------------------------------
put_string:;字符串显示	输入ds:ebx 串地址 串以0为结束符
push ecx
.getc:
mov cl,[ebx]
or cl,cl
jz .exit
call put_char
inc ebx
jmp .getc

.exit:
pop ecx
retf ;段间返回 pop ip pop cs

;----------------------------------------------------------
put_char:;在当前光标处显示一个字符，并推进光标，仅用于段内调用 输入cl ascii码
pushad;压入所有通用寄存器 push eax push ebx ... push edi

;以下取光标位置
mov dx,0x3d4
mov al,0x0e
out dx,al
inc dx
in al,dx
mov ah,al;光标位置高16位

dec dx
mov al,0x0f
out dx,al
inc dx
in al,dx;光变位置低16位
mov bx,ax;bx即光标位置的16位数字

cmp cl,0x0d ;回车符？
jnz .put_0a
mov ax,bx
mov bl,80
div bl
mul bl
mov bx,ax;通过先/80 商再* 80实现光标到最后一行开头
jmp .set_cursor

.put_0a:
cmp cl,0x0a;换行符？
jnz .put_other
add bx,80
jmp .roll_screen

.put_other:
push es
mov eax,video_ram_seg_sel
mov es,eax
shl bx,1;bx=bx*2
mov [es:bx],cl
pop es

;推进光标
shr bx,1;bx恢复
inc bx

.roll_screen:
cmp bx,2000;?要滚屏
jl .set_cursor ;less 小于 可以用于有符号数 jb无符号数

push ds
push es
mov eax,video_ram_seg_sel
mov ds,eax
mov es,eax
cld;df位置0 正向串传输
mov esi,0xa0 ;从第二行开始
mov edi,0x00 ;传到第一行
mov ecx,1920 ;传24行
rep movsw ;书中这句是movsd我认为错了，因为总共要传送80*24个字符，一个字符加一个属性共一个字 所以是 movsw 等会去试试看看谁错了
mov bx,3840
mov ecx,80;清除最后一行
.cls:
mov word [es:bx],0x0720
add bx,2
loop .cls
pop es
pop ds

mov bx,1920;
.set_cursor:
mov dx,0x3d4
mov al,0x0e
out dx,al
inc dx
mov al,bh
out dx,al
dec dx
mov al,0x0f
out dx,al
inc dx
mov al,bl
out dx,al

popad
ret

;----------------------------------------------------------
read_hard_disk_0:;从硬盘读取一个扇区 输入 eax 逻辑扇区号 ds:ebx 目标缓冲区地址 返回 ebx+=512
push eax
push ecx
push edx

push eax
mov dx,0x1f2
mov al,1
out dx,al                          ;读取的扇区数

inc dx                             ;0x1f3
pop eax
out dx,al                          ;LBA地址7~0

inc dx                             ;0x1f4
mov cl,8
shr eax,cl
out dx,al                          ;LBA地址15~8

inc dx                             ;0x1f5
shr eax,cl
out dx,al                          ;LBA地址23~16

inc dx                             ;0x1f6
shr eax,cl
or al,0xe0                         ;第一硬盘  LBA地址27~24
out dx,al

inc dx                             ;0x1f7
mov al,0x20                        ;读命令
out dx,al

.waits:
in al,dx
and al,0x88
cmp al,0x08
jnz .waits                         ;不忙，且硬盘已准备好数据传输 

mov ecx,256                        ;总共要读取的字数
mov dx,0x1f0
.readw:
in ax,dx
mov [ebx],ax
add ebx,2
loop .readw

pop edx
pop ecx
pop eax

retf                               ;段间返回 

;----------------------------------------------------------
put_hex_dword:;在当前光标处以16进制来显示一个双字并推进光标 输入 edx 要显示的数字，可以用来调试
pushad
push ds
mov ax,core_data_seg_sel
mov ds,ax

mov ebx,bin_hex;ebx为数字-ascii码转换表首地址
mov ecx,8
.xlt:
rol edx,4;将最高4位放到最低4位
mov eax,edx
and eax,0x0000000f
xlat;将[ds:bx+al]送入al,也就是查表指令，找到对应的16进制数的ascii码
 
push ecx
mov cl,al
call put_char
pop ecx
loop .xlt

pop ds
popad
retf

;----------------------------------------------------------
allocate_memory: ;分配内存 输入 ecx希望分配的字节数输出 ecx 起始线性地址
push ds
push eax
push ebx

mov eax,core_data_seg_sel
mov ds,eax

mov eax,[ram_alloc];拿到可分配内存的起始地址
add eax,ecx;eax即使下一次分配时的起始地址
;应当由检测可用内存数量的指令，但是这里没有写

mov ecx,[ram_alloc];返回分配的起始地址
mov ebx,eax
and ebx,0xfffffffc ;11111111_11111111_11111111_11111100
add ebx,4;强制4字节对齐
test eax,0x00000003;test 相当于or当时结果不赋值 00000011,如果结果为0说明4字节对齐了
cmovnz eax,ebx;test eax,3不为0时，也就是eax本身不对齐时就用ebx
mov [ram_alloc],eax

pop ebx
pop eax
pop ds
retf

;----------------------------------------------------------
set_up_gdt_descriptor:;在GDT内安装一个新的描述符
;输入 edx:eax 描述符 输出 cx 描述符选择子
push eax
push ebx
push edx

push ds
push es

mov ebx,core_data_seg_sel
mov ds,ebx

sgdt [pgdt];将GDTR寄存器的基地址和边界信息保存到指定的内存位置，48位

mov ebx,mem_0_4_gb_seg_sel
mov es,ebx

movzx ebx,word [pgdt] ;movzx用于将较短位数的源操作数传送到较大的目的操作数，用0扩展高位
inc bx;GDT表的字节长度，也是新的描述符的偏移
add ebx,[pgdt+2] ;新描述符的线性地址

mov [es:ebx],eax
mov [es:ebx+4],edx

add word [pgdt],8;修改描述符表界限

lgdt [pgdt]

mov ax,[pgdt] ;得到界限
xor dx,dx
mov bx,8
div bx;例如两个描述符 0 1则 段界限15 15/8=1.。。7所以可以直接当作索引
mov cx,ax
shl cx,3;左移3位 成为正确的段选择子

pop es
pop ds

pop edx
pop ebx
pop eax
retf

;----------------------------------------------------------
make_seg_descriptor:;构造段描述符
;输入 eax 线性地址 ebx 段界限 ecx 属性（高32位属性的记录，非属性为0） 返回edx:eax 描述符
mov edx,eax
shl eax,16;线性地址低16位
or ax,bx;描述符低32位构造完成

and edx,0xffff0000;线性地址高16位
rol edx,8;32位 最高8位是线性地址的16-23 最低8位是线性地址的24-31位，和正确的位置相反
bswap edx;交换成正确的

xor bx,bx;ebx低16位清0，因为低16位已经装到描述符的低32位里了，界限只剩下高4位没装配了
or edx,ebx ;装配高4位

or edx,ecx;装配属性
retf

;==========================================================
SECTION core_data vstart=0 ;系统核心数据段

;----------------------------------------------------------
pgdt dw 0
dd 0 ;用于设置和修改GDT
ram_alloc dd 0x00100000 ;记录下次分配内存时的起始地址

;符号地址检索表
salt:
;----------------------------------------------------------
salt_1: db '@PrintString'
times 256-($-salt_1) db 0;开头256个字节用于保存函数名
dd put_string   
dw sys_routine_seg_sel
;----------------------------------------------------------
salt_2: db '@ReadDiskData'
times 256-($-salt_2) db 0;开头256个字节用于保存函数名
dd read_hard_disk_0   
dw sys_routine_seg_sel
;----------------------------------------------------------
salt_3: db '@PrintDwordAsHexString'
times 256-($-salt_3) db 0;开头256个字节用于保存函数名
dd put_hex_dword   
dw sys_routine_seg_sel
;----------------------------------------------------------
salt_4: db '@TerminateProgram'
times 256-($-salt_4) db 0;开头256个字节用于保存函数名
dd return_point  
dw core_code_seg_sel
;----------------------------------------------------------
salt_item_len equ $-salt_4;单项长度常数 256+4+2=262
salt_items equ ($-salt)/salt_item_len;项数 总长度/单项长度

message_1 db  '  If you seen this message,that means we '
db  'are now in protect mode,and the system '
db  'core is loaded,and the video display '
db  'routine works perfectly.',0x0d,0x0a,0

message_5 db  '  Loading user program...',0

do_status db 'Done.',0x0d,0x0a,0 ;先回车再换行 \r\n

message_6 db  0x0d,0x0a,0x0d,0x0a,0x0d,0x0a
db  '  User program terminated,control returned.',0

bin_hex db '0123456789ABCDEF';put_hex_dword子过程用的查找表 

core_buf times 2048 db 0 ;内核用的缓冲区,用来装用户程序的头部（第一个扇区）

esp_pointer dd 0 ;内核用来临时保存自己的栈指针

cpu_brnd0 db 0x0d,0x0a,' ',0
cpu_brand times 52 db 0
cpu_brnd1 db 0x0d,0x0a,0x0d,0x0a,0

;==========================================================
SECTION core_code vstart=0

;----------------------------------------------------------
load_relocate_program:;加载并重定位用户程序
;输入 esi 其实逻辑扇区号 返回 ax 用户程序头部的选择子
push ebx
push ecx
push edx
push esi
push edi

push ds
push es

mov eax,core_data_seg_sel
mov ds,eax ;切换到内核数据段

mov eax,esi 
mov ebx,core_buf
call sys_routine_seg_sel:read_hard_disk_0

;以下判断整个程序有多大
mov eax,[core_buf];用户程序起始位置的4字节就是大小
mov ebx,eax
and ebx,0xfffffe00;使其512字节对齐
add ebx,512
test eax,0x000001ff;程序的大小正好是512的倍数吗？
cmovnz eax,ebx ;如果不是就用对齐后+512的ebx 
mov ecx,eax;如果是对齐就直接用 （相当于之前用的/512看有没有余数）

call sys_routine_seg_sel:allocate_memory;申请内存
mov ebx,ecx;申请到的首地址
push ebx
xor edx,edx
mov ecx,512
div ecx
mov ecx,eax;总扇区数

mov eax,mem_0_4_gb_seg_sel
mov ds,eax

mov eax,esi;起始扇区号
.b1:
call sys_routine_seg_sel:read_hard_disk_0
inc eax
loop .b1 ;循环读完整个用户程序（虽然一开始读了1个头部扇区，但是那是读到内核缓冲区的，不是最终的内存地址，所以这次还是带上第一个扇区，没有-1）

;建立程序头部段描述符
pop edi;回到程序装载首地址
mov eax,edi;头部段描述符的线性基地址
mov ebx,[edi+0x04];段长度
dec ebx;段界限
mov ecx,0x00409200;属性
call sys_routine_seg_sel:make_seg_descriptor
call sys_routine_seg_sel:set_up_gdt_descriptor
mov [edi+0x04],cx;将原来是header段长度的0x04有效地址的内容改成段选择子

;建立程序代码段描述符
mov eax,edi
add eax,[edi+0x14]                 ;代码起始线性地址
mov ebx,[edi+0x18]                 ;段长度
dec ebx                            ;段界限
mov ecx,0x00409800                 ;字节粒度的代码段描述符
call sys_routine_seg_sel:make_seg_descriptor
call sys_routine_seg_sel:set_up_gdt_descriptor
mov [edi+0x14],cx;写入段选择子

;建立程序数据段描述符
mov eax,edi
add eax,[edi+0x1c]                 ;数据段起始线性地址
mov ebx,[edi+0x20]                 ;段长度
dec ebx                            ;段界限
mov ecx,0x00409200                 ;字节粒度的数据段描述符
call sys_routine_seg_sel:make_seg_descriptor
call sys_routine_seg_sel:set_up_gdt_descriptor
mov [edi+0x1c],cx;写入段选择子

;建立程序堆栈段描述符
mov ecx,[edi+0x0c]                 ;4KB的倍率 
mov ebx,0x000fffff
sub ebx,ecx                        ;得到段界限
mov eax,4096                        
mul dword [edi+0x0c]                         
mov ecx,eax                        ;准备为堆栈分配内存 
call sys_routine_seg_sel:allocate_memory
add eax,ecx                        ;得到堆栈的高端物理地址 
mov ecx,0x00c09600                 ;4KB粒度的堆栈段描述符
call sys_routine_seg_sel:make_seg_descriptor
call sys_routine_seg_sel:set_up_gdt_descriptor
mov [edi+0x08],cx;写入段选择子

;重定位salt
mov eax,[edi+0x04];用户程序header段选择子
mov es,eax;es->用户程序header段
mov eax,core_data_seg_sel
mov ds,eax

;下面代码是对用户程序内调用的函数地址重定向，讲用户程序header段的salt每个项都拿到内核salt中比对，如果发现函数名完全一样，就重写用户程序内部的函数地址

cld;置DF位0 esi edi 递增
mov ecx,[es:0x24];用户程序的salt条目数 外循环次数
mov edi,0x28;0x28是用户程序salt的有效地址
.b2:
push ecx
push edi

mov ecx,salt_items;内核中salt条目数 内循环次数
mov esi,salt;内核salt有效地址
.b3:
push edi
push esi
push ecx

mov ecx,64;函数表中，每个表项的名称区的比对次数 64
repe cmpsd;每次比较4字节（cmpsd ds:esi es:edi 以4字节位单位比较）
jnz .b4
mov eax,[esi];如果匹配，结束时esi即指向地址数据
mov [es:edi-256],eax;用户程序salt没有专门给函数地址和段选择子留下空间，所以找到内核中对应函数地址后，直接写在函数名里
mov ax,[esi+4]
mov [es:edi-252],ax

.b4:
pop ecx
pop esi
add esi,salt_item_len;比较下一个内核salt项目
pop edi;而用户程序条目由于没找到对应的 不变继续找
loop .b3

pop edi
add edi,256
pop ecx
loop .b2

mov ax,[es:0x04];返回用户程序header段选择子

pop es
pop ds

pop edi
pop esi
pop edx
pop ecx
pop ebx
ret

;----------------------------------------------------------
start:
mov ecx,core_data_seg_sel
mov ds,ecx

mov ebx,message_1
call sys_routine_seg_sel:put_string

;显示处理器品牌信息 
mov eax,0x80000002
cpuid
mov [cpu_brand + 0x00],eax
mov [cpu_brand + 0x04],ebx
mov [cpu_brand + 0x08],ecx
mov [cpu_brand + 0x0c],edx

mov eax,0x80000003
cpuid
mov [cpu_brand + 0x10],eax
mov [cpu_brand + 0x14],ebx
mov [cpu_brand + 0x18],ecx
mov [cpu_brand + 0x1c],edx

mov eax,0x80000004
cpuid
mov [cpu_brand + 0x20],eax
mov [cpu_brand + 0x24],ebx
mov [cpu_brand + 0x28],ecx
mov [cpu_brand + 0x2c],edx

mov ebx,cpu_brnd0
call sys_routine_seg_sel:put_string
mov ebx,cpu_brand
call sys_routine_seg_sel:put_string
mov ebx,cpu_brnd1
call sys_routine_seg_sel:put_string

mov ebx,message_5
call sys_routine_seg_sel:put_string
mov esi,50 ;指定用户程序的逻辑扇区
call load_relocate_program

mov ebx,do_status
call sys_routine_seg_sel:put_string

mov [esp_pointer],esp

mov ds,ax;
jmp far [0x10];控制权交给用户程序
;堆栈可能切换

return_point:
mov eax,core_data_seg_sel
mov ds,eax

mov eax,core_stack_seg_sel
mov ss,eax
mov esp,[esp_pointer]

mov ebx,message_6
call sys_routine_seg_sel:put_string
;这里可以放置清除用户程序的各种描述符的指令
;可以加载并启动其他程序
hlt

;==========================================================
SECTION core_trail
;----------------------------------------------------------
core_end:
```

​	用户程序：

```assembly
;==========================================================
SECTION header vstart=0
program_length dd program_end ;程序总长度 0x00
head_len dd header_end  ;header段的总长度 0x04
stack_seg dd 0           ;用于接收堆栈选择子8
stack_len dd 1			;用于接收堆栈大小 c 

prg_entry dd start ;程序入口 10
code_seg dd section.code.start ;代码段位置 14
code_len dd code_end ;代码段长度 0x18

data_seg dd section.data.start;数据段位置 1c
data_len dd data_end ;数据段长度 20

;----------------------------------------------------------
;符号地址检索表（函数名）
salt_items dd (header_end-salt)/256;项数  24
salt: ;28
PrintString db '@PrintString'
times 256-($-PrintString) db 0

TerminateProgram db '@TerminateProgram'
times 256-($-TerminateProgram) db 0

ReadDiskData db '@ReadDiskData'
times 256-($-ReadDiskData) db 0

header_end:

;==========================================================
SECTION data vstart=0
buffer times 1024 db 0 ;缓冲区
message_1 db 0x0d,0x0a,0x0d,0x0a
db '**********User program is runing**********'
db 0x0d,0x0a,0
message_2 db '  Disk data:',0x0d,0x0a,0

data_end:

;==========================================================
[bits 32]

;==========================================================
SECTION code vstart=0
start:
mov eax,ds;ds是用户程序header段
mov fs,eax

mov eax,[stack_seg]
mov ss,eax
mov esp,0

mov eax,[data_seg]
mov ds,eax

mov ebx,message_1
call far [fs:PringString]

mov eax,100
mov ebx,buffer
call far [fs:ReadDiskData]

mov ebx,message_2
call far [fs:PrintString]

mov ebx,buffer
call far [fs:PringString]
jmp far [fs:TerminateProgram]

code_end:

;==========================================================
SECTION trail
;----------------------------------------------------------
program_end:
```

​	![SharedScreenshot12](/assets/img/SharedScreenshot12.jpg)

​	上述代码运行正确（引导-内核-用户程序-读100扇区ascii文本）