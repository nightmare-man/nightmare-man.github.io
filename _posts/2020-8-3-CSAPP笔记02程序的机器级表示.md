---
layout: post
title: CSAPP笔记02程序的机器级表示
subtitle: CSAPP笔记02程序的机器级表示
date: 2020-08-03
author: nightmare-man
tags: 计算机组成原理
---
# CSAPP笔记02程序的机器级表示

### 0x00 本章概述

​	计算机直接执行**机器代码**，用字节序列编码低级操作，包括处理数据、管理内存、读写储存设备上的数据和网络通信。编译器基于编程语言的规则、目标机器的指令集和操作系统的管理，经过预处理、编译、汇编和链接四个步骤生成可执行的机器代码。gcc c语言编译器以**汇编代码**的形式产生输出，**汇编语言是机器语言的文本形式**。

​	能够阅读和理解汇编代码是一项很重要的技能，阅读和理解编译器产生的汇编代码，能够①理解编译器的优化能力，并分析代码中隐藏的低效率。②了解到高级语言中的抽象层的具体实现。③了解底层漏洞是如何出现的，以及如何防护。

​	源代码和对应的汇编代码之间的关系通常不容易建立，通过汇编代码推测出源代码是一种逆向工程（reverse engineering）。

​	不同于高级语言，机器代码和具体的硬件平台直接相关，而中间的汇编语言，则又和负责编译的编译器有关。

​	本章的机器代码基于x86-64，汇编语言版本是gcc默认的AT&T（业界另一种主流是Intel的版本），本章主要介绍x86-64中那些符合现代操作系统的特性，对于历史遗留的兼容特性，不做介绍。

​	8086是第一代单芯片，16位微处理器之一，8087是浮点协处理器。

​	80286提出了引入了保护模式。

​	80386增加了平坦寻址模式（flat adressing model），并且将体系扩展到32位。

​	Pentium（奔腾系列）加入了条件传送，并引入了**SSE指令**，用来一次处理128位向量（主要用于浮点数，废除了x87协处理器） 增加了**超线程（hyperthreading）**，该技术能够在同一个处理器上**同时**处理两个程序（不是分时占用）

​	Core（酷睿系列）加入了**AVX指令**，即SSE的扩展，一次能处理512位向量。

​	IA32是指Intel Architechure 32-bit，也包括现在的64位扩展，但是我们一般成为x86-64，也称作x86系列代指所有。	



### 0x01 程序编码

```c
gcc -Og p1.c p2.c -o p.out 
```

​	上述命令能够生成符合原始c代码的机器代码，-Og即关闭优化。

​	gcc的工作流程：①gcc首先预处理c代码，将#include命令指定的文件插入进来，并替换所有用#define声明的宏。②**编译器**编译两个源文件，产生两个汇编文件，p1.s p2.s。③**汇编器**会将汇编代码转化成二进制目标文件代码p1.o和p2.o。目标代码是机器代码的一种形式，包含所有指令的二进制形式，但是还没有填入全局地址（在被运行时填入）。④**链接器**将两个目标代码文件与实现库函数（例如printf）的代码合并（.o文件），并最终产生可执行代码文件p.out

​	**机器级代码（汇编语言）：**

​	对于汇编或者机器语言，**指令集架构**（Instruction Set Architecture,ISA)定义了处理器的状态、指令的格式、以及每条指令对状态的影响，ISA将程序的行为描述成**好像**每条指令都是按顺序执行的，一条一条的，但实际上时并发执行许多指令的，但是**最终运行结果和ISA指定的顺序执行的结果一致**		

​	程序使用的是**虚拟内存**，将内存模型看作一个非常大的字节数组，但实际上，储存器系统的实现时多个硬件储存器和操作系统配合起来实现的。

​	汇编/机器代码和原始的c的代码差别很大，因为c是对机器汇编的进一步抽象，隐藏了许多细节：

​	①程序计数器 （Program Counter，PC），在x86-64(x86的64位扩展)上用%rip表示（%是AT&T的写法，Intel的汇编不用），给出下一条指令在内存（虚拟内存）中的地址。

​	②通用寄存器16个，储存64位的数据，可以储存地址（对应c语言的指针）或者整数数据。

​	③条件码寄存器（状态字寄存器/标志寄存器），保存着最近执行的指令的信息。

​	④一组向量寄存器，用来保存一个或者多个整数或者浮点数。（SSE AVX）

​	程序内存包括：程序的可执行机器码，操作系统的一些信息（调用历程？），用来管理过程调用和返回的运行时栈，以及用户分配的内存块（如malloc从堆中分配）。

​	在x86-64中虚拟地址是64位的字长（8字节 ）来表示的，目前的操作系统中，高16位设置0，也就是低48位有效，实际能够访问的是0-64TB，操作系统负责管理虚拟地址空间，cpu根据操作系统的设置将虚拟地址翻译成物理地址。

​	一条机器指令只执行一个非常基本的操作，如两个寄存器中的数字运算，储存器和寄存器之间传送数据（不支持直接储存器到储存器，DMA或许可以？），或者条件分支转移到新的指令地址。编译器负责从c语言转换到机器指令序列，从而是实现程序的结构（类似于表达式求值，循环或者过程调用和返回）。

​	使用：

```c
gcc -Og -S test.c
```

​	可以将c语言文件预处理并编译成汇编文件，不继续汇编成机器指令。

​	要查看机器代码对应的汇编指令，可以用反汇编器（disassembler），比如gdb调试或者objdump。也就是我们先用

```c
gcc -Og test.c -o test.out
```

​	将c代码生成可执行文件test.out，然后用:

```c
objdump -d test.out
```

​	指令就可以查看机器码对应的汇编指令。

![image-20200803172936940](/assets/img/image-20200803172936940.png)

​	反汇编和机器代码的特性：

​	①x86-64的指令从1-15字节不等，越常用指令所需字节越少

​	②指令的设计方式是，从某个给定的位置开始，可以将字节唯一的解码成机器指令（对应二进制构造数的叶节点，参考huffman tree）

​	③反汇编器只基于机器码中的字节序列来确定汇编代码。

​	④反汇编器对汇编指令的命名和gcc生成的汇编代码略有不同，但是功能是一样的，比如反汇编生成的过程返回指令是retq（参考上图），而gcc生成的是ret。

​	要生成实际可执行的diamond，需要**对一组目标代码文件运行链接器**，而这一组目标代码中必须有一个main函数：

```c
gcc -Og main.c func.c -o 1.out
```

​	文件1.out的大小远远大于这个文件生成的机器代码，因为还链接了用来启动和终止程序的机器代码，以及和操作系统交互的代码（例如pritf的代码）。

​	**汇编代码的格式：**

​	![image-20200803174151270](/assets/img/image-20200803174151270.png)	

​	所有"."开头的行都是指导汇编器和链接器工作的**伪指令**，阅读时通常可以忽略。

​	本书中使用的时ATT(根据美国的通讯公司AT&T命名)，这是GCC和OBJDUMP等一些工具的默认格式，但是Microsoft以及Intel等使用的汇编代码是Intel格式的，这两种格式在许多方面有所不同：

​	①Intel代码省略了指令大小的后缀，取而代之的是 double word ptr等，而ATT是movq movl。

​	②Intel代码省略了寄存器前面的“%”，用的是rbx而不是ATT的"%rbx"。

​	③ATT源操作数在左，目的操作数在右，而Intel的相反：

```assembly
movq %rbx,%rax   ;ATT写法 rbx->rax
mov rbx,rax 	 ;Intel写法 rax->rbx
```

​	c语言允许内联汇编语言，或者用gcc命令和汇编代码合并起来。



### 0x02 数据格式

​	由于x86系列处理器最开始是16位，因此Intel用**字**(word)来表示16位的数据类型，因此，城32位数为**双字**(double words)，64位为**四字**(quad words)

![image-20200803175551551](/assets/img/image-20200803175551551.png)

​	以上是c语言中的基本数据类型在64为机器中对应的大小。大多数gcc生成的汇编代码指令都有一个字符后缀，用来表明操作数的大小（objdump里没这个后缀，Intel格式也没有）。例如mov指令就有movb（传送字节）movw（传送字）movl（传送双字） movq（传送四字）。	



### 0x03 访问信息

​	x86-64cpu包括16个储存64为值的**通用目的寄存器**，用来储存整数或者地址（指针）。

![image-20200803180524438](/assets/img/image-20200803180524438.png)

​	可以看到每个寄存器都有多个名字，不同名字对应这x86历史的不同时期cpu的位数，例如16位时期称为%ax（也可用%al,来访问8位）,32位时期则是%eax，64位是%rax。

​	指令可以对这16个寄存器的不同位置进行访问，例如movq就是访问全部64位 movb访问低16位（不影响其余高48位）等等，但是就是movl比较特殊，**或者说对低32位访问比较特殊，会自动清除高32位**（历史遗留原因）。

​	

​	**寻址方式**：

​	大多数指令有一个或者多个操作数，指示出要使用的数据的值的方法称为**寻址方式**，有三大类：

​	①**立即数immediate**：ATT写法是$后面跟一个数字，不同指令的允许的立即数范围是不同的，比如movb （0-255）

​	②**寄存器register**：表示某个寄存器里的内容，根据名称不同使用不同的寄存器里的不同部分（低8字节/低16字节/低32字节/全部64字节）

​	③内存引用，根据计算出来的地址（通常称为有效地址/偏移地址,因为段地址存在），访问内存的某个位置。内存引用有4个部分 **基址寄存器 变址寄存器 比例系数 立即数偏移**，组合城的具体的寻址方式如下：

![image-20200803181744357](/assets/img/image-20200803181744357.png)

​	

​	**数据传送指令：**

​	![image-20200803182123083](/assets/img/image-20200803182123083.png)

​	以上是最简单的数据传送指令mov类，几个指令的区别是传送的数据大小不同，需要注意的是，选用的寄存器要匹配，例如movw %ax,%bx 而不是movw %rax,%rax 因为是16为数据，要使用16位寄存器。x86-64限制，不能源操作数和目的操作数都是内存地址。

​	以下是将位数较小的源操作数移动到位数较大的目的操作数的**扩展移动指令：**

![image-20200803182448934](/assets/img/image-20200803182448934.png)

​	可以看到分为两类，**0扩展**和**符号扩展**，movz类和movs类（z:zero s:sign） 可以看到没有movzlq,因为movl就自动会将目的寄存器的高32位清零，movl %eax,%ebx即相当于movzlq %eax,%rbx。

​	还有类似的**专用扩展指令**，cltq用来将%eax符号扩展成%rax。效果与movslq %eax,%rax效果完全一致。**不过指令对应的机器码更短**



​	**压入和弹出栈数据**

​	pushq %rbp是压数据入栈相当于sub $8,%rsp movq %rbp,(%rsp)

​	popq %rbp则是出栈到%rbp 相当于movq (%rsp),%rbp  addq $8,%rsp 

​	因为栈和程序的其他数据都是在同一内存（实际上是同一个段 平坦模型），所以可以用寻址方式直接访问栈中的数据，例如 movq 8(%rsp),%rdx 就是将栈顶的前一个4字复制到rdx里。

​	

​	