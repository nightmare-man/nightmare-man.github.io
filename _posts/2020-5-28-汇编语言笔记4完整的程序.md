---
layout: post
title: 汇编语言笔记4完整的程序
subtitle: 汇编语言笔记4完整的程序
date: 2020-05-28
author: nightmare-man
tags: 8086汇编
---

# 汇编语言笔记4完整的程序

### 0x00 源程序从写出到执行

​		一个程序从.asm汇编源码 到被编译成.obj文件，再链接成.exe可执行文件

​		可执行文件包含两部分：1程序和数据  2相关的描述信息（如程序有多大，从哪里开始执行）

​		操作系统依照可执行文件中的描述信息，将可执行文件中的机器码和数据加载进内存，并进行相关的初始化（比如设置cs：ip）然后由cpu执行程序



​		以下是一个简单的源程序

​		assume cs:codesg

​		codesg segment

​				mov ax,0123h

​				mov bx,0456h

​				add ax,bx

​				add ax,ax

​				

​				mov ax,4c00h

​				int 21h

​		codesg ends

​		end

​		该源程序包含两部分 1 伪指令 2汇编指令

​		**伪指令：**没有对应的机器指令，最终不被cpu执行，由编译器执行   xxx segment 和 xxx ends  是一对成对使用的伪指令，这是在写可被编译器编译的汇编程序时，必须要用到的一对伪指令。用来定义一个段，前者说明段开始，后者说明结束，一个段必须要有一个名称来标识

![QQ截图20200528211146](/assets/img/QQ截图20200528211146.png)

​		end是一个汇编程序的结束标记，编译器在编译汇编程序的过程中，如果碰到end 就结束对源程序的编译。所以如果程序写完了，就要加上end，注意end 和ends不同 ends 是用来结束一个段，前面必须由标号 xxx ends

​		assume 这条伪指令的含义为“假设”。它假设某一段寄存器和程序中的莫i一个段相关联。如assume cs:codesg 就是将cs段寄存器和codesg相关联

​		**源程序中的程序** 代码段的汇编指令组成了最终由计算机执行的程序

​		**标号** 如codesg 一个标号指代了一个地址，codesg作为一个段的名称，最终将被编译、连接程序处理为一个段的段地址

​		**程序的结构** 源程序是由一些段构成的，可以在这些段里存放代码，数据或者将某个段作为栈空间



### 0x01 程序的返回

​		![QQ截图20200528212317](/assets/img/QQ截图20200528212317.png)

​		也就是 mov 4c00h

​					int 21 

​		是程序返回，不深究



### 0x02 语法错误与逻辑错误

​		程序在编译时发生的错误是语法错误

![QQ截图20200528212523](/assets/img/QQ截图20200528212523.png)

​		在运行时发生的错误是逻辑错误

​	![QQ截图20200528212601](/assets/img/QQ截图20200528212601.png)

​		（缺少程序返回）



### 0x03 编辑 编译 链接 调试程序

​		使用记事本编写源程序，保存为.asm格式，然后用 masm xxx.asm来编译 再用 link xxx.obj来链接 最终得到 xxx.exe 可以debug xxx.exe来调试 



### 0x04 谁将exe程序装入内存？

### ![QQ截图20200528213002](/assets/img/QQ截图20200528213002.png)

​		操作系统的外壳shell 或者说 接口 程序 将exe装入内存



### 0x05 dos exe文件被装入内存的过程

![QQ截图20200528213321](/assets/img/QQ截图20200528213321.png)

​		1先在内存中找到一个足够大的起始地址为 sa：0000 （也就是起始地址的偏移地址为0的 也就是起始地址为16的整数倍的地址）空闲内存区 ds寄存器保存着sa的值

​		2这段内存的前256个字节 也就是sa：0-ff  为psp 区，程序的开始

​		3其余部分为程序区装入程序（程序区距离psp起始地址256个字节 可以认为程序区是另一个段 那么段地址为sa+10h）