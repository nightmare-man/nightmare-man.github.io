---
layout: post
title: 从实模式到保护模式笔记10任务及特权级保护
subtitle: 从实模式到保护模式笔记10任务及特权级保护
date: 2020-07-11
author: nightmare-man
tags: x86汇编
---
# 从实模式到保护模式笔记10任务及特权级保护

### 0x00 代码

```assembly
;以下是内核段选择子的常量，由内核引导程序和内核协商
core_code_seg_sel equ 0x38;内核代码段选择子
core_data_seg_sel equ 0x30;内核数据段选择子
sys_routine_seg_sel equ 0x28;系统公共例程的选择子
video_ram_seg_sel equ 0x20;显存区的选择子
core_stack_seg_sel equ 0x18;内核堆栈选择子
mem_0_4_gb_seg_sel equ 0x08;整个0-4GB内存的段选择子

;===========================================================
;以下是系统的头部段，提供用于加载核心程序的信息
core_length dd core_end ;内核总长度
sysy_routine_seg dd section.sys_routine.start
core_data_seg dd section.core_data.start
core_code_seg dd section.core_code.start
core_entry dd start
dw core_code_seg_sel

;===========================================================
[bits 32]
;===========================================================
;以下是系统公共例程代码段
SECTION sys_routine  vstart=0

;-----------------------------------------------------------
;字符串显示例程 显示0终止的字符串并移动光标 输入ds:ebx串地址
put_string:
push ecx
.getc:
mov cl,[ebx]
or cl,cl
jz .exit;为0就终止
call put_char;不为0就显示
inc ebx
jmp .getc

.exit:
pop ecx
retf ;段间返回 所以只能远距离段间调用

;-----------------------------------------------------------
;光标处显示一个字符，并推进光标 输入cl为字符ascii码
put_char:
pushad;压入所有通用寄存器

;以下取光标位置
mov dx,0x3d4
mov al,0x0e;光标位置是16位，往3d4写0x0e 拿到高8位 写0x0f是低8位
out dx,al
inc dx;0x3d5
in al,dx;
mov ah,al

mov dx,0x3d4
mov al,0x0f
out dx,al
inc dx
in al,dx
mov bx,ax;bx即光标

cmp cl,0x0d;\r\n recycle 回车 newline 换行 先判断回车
jnz .put_0a
mov ax,bx
mov bx,80
div bl
mul bl;先除80再用商乘80回到开头位置
mov bx,ax
jmp .set_cursor;设置光标

.put_0a:
cmp cl,0x0a
jnz .put_other
add bx,80
jmp .roll_screen

.put_other:
push es
mov eax,video_ram_seg_sel
mov es,eax
shl bx,1;光标 *2 得到显存位置
mov [es:bx],cl
pop es

shr bx,1
inc bx

.roll_screen:
cmp bx,2000;先显示字符或者换行，再看看是不是超出了屏幕滚屏
jl .set_cursor

push ds
push es
mov eax,video_ram_seg_sel
mov ds,eax
mov es,eax
cld
mov esi,0xa0;从0xa0 到0x00
mov edi,0x00
mov ecx,1920;24行
rep movsw ;要移动24*80*2个字节 所以是1920个movsw 书中写的是movsd
;我认为是错的
mov bx,3840;显存地址到最后一行开头
mov ecx,80

.cls:
mov word [es:bx],0x0720
add bx,2
loop .cls;最后一行清除

pop es
pop ds
mov bx,1920

.set_cursor:
mov dx,0x3d4
mov al,0x0e
out dx,al
inc dx
mov al,bh;写入新光标高8位
out dx,al

dec dx
mov al,0x0f
out dx,al
inc dx
mov al,bl
out dx,al;写入新光标低8位

popad
ret

;-----------------------------------------------------------
read_hard_disk_0:                           ;从硬盘读取一个逻辑扇区
;EAX=逻辑扇区号
;DS:EBX=目标缓冲区地址
;返回：EBX=EBX+512
push eax 
push ecx
push edx

push eax

mov dx,0x1f2
mov al,1
out dx,al                          ;读取的扇区数

inc dx                             ;0x1f3
pop eax
out dx,al                          ;LBA地址7~0

inc dx                             ;0x1f4
mov cl,8
shr eax,cl
out dx,al                          ;LBA地址15~8

inc dx                             ;0x1f5
shr eax,cl
out dx,al                          ;LBA地址23~16

inc dx                             ;0x1f6
shr eax,cl
or al,0xe0                         ;第一硬盘  LBA地址27~24
out dx,al

inc dx                             ;0x1f7
mov al,0x20                        ;读命令
out dx,al

.waits:
in al,dx
and al,0x88
cmp al,0x08
jnz .waits                         ;不忙，且硬盘已准备好数据传输 

mov ecx,256                        ;总共要读取的字数
mov dx,0x1f0
.readw:
in ax,dx
mov [ebx],ax
add ebx,2
loop .readw

pop edx
pop ecx
pop eax

retf                               ;段间返回 

;-----------------------------------------------------------
;以16进制形式显示一个双字 输入 edx 待显示的双字
put_hex_dword: 

pushad
push ds
mov ax,core_data_seg_sel
mov ds,ax

mov ebx,bin_hex;指向内核数据段的转换表
mov ecx,8;8位16进制数
.xlt:
rol edx,4;循环左移 ror循环右移
mov eax,edx
and eax,0x0000000f;取最低4位
xlat ;查表


push ecx
mov cl,al
call put_char
pop ecx

loop .xlt

pop ds
popad
retf

;-----------------------------------------------------------
;动态分配内存 输入 ecx 希望分配的字节数 输出ecx 起始线性地址
allocate_memory:
push ds
push eax
push ebx

mov eax,core_data_seg_sel
mov ds,eax

mov eax,[ram_alloc]
add eax,ecx ;下一次分配的起始地址
;可以检测可用内存数量的指令（即新地址是否越界，越界说明本次分配内存不足）

mov ecx,[ram_alloc];返回起始地址

mov ebx,eax
and ebx,0xfffffffc;最低c 12 1100即最低2位置0 强制4字节对齐
add ebx,4
test eax,0x00000003;看看eax是不是本来就4字节对齐0011
cmovnz eax,ebx ;如果上面结果不是0，就说明没对齐，就用对齐后的ebx
mov [ram_alloc],eax ;写入新地址
;用cmovnz 主要是为了减少jmp的使用 类似还有cmovz 
pop ebx
pop eax
pop ds
retf

;-----------------------------------------------------------
;GDT安装新的描述符，输入 edx:eax 描述符64位 返回cx描述符选择子
set_up_gdt_descriptor:
push eax
push ebx
push edx
push ds
push es

mov ebx,core_data_seg_sel
mov ds,ebx

sgdt [pgdt]

mov ebx,mem_0_4_gb_seg_sel
mov es,ebx

movzx ebx,word [pgdt];mov with zero extension 扩展传送，不加ptr
;将较小位数的源操作数传送到较大位数的目的操作数 高位以0填充
inc bx;GDT的长度,同时这刚好等于新描述符的选择子
mov cx,bx
add ebx,[pgdt+2];新描述符的线性地址

mov [es:ebx],eax
mov [es:ebx+4],edx

add word [pgdt],8;界限+8
lgdt [pgdt];重新装载gdt

pop es
pop ds
pop edx
pop ebx
pop eax
retf

;-----------------------------------------------------------
;构造一个段描述符 输入 eax 线性基址 ebx 段界限 ecx 属性 返回
;edx：eax为描述符
make_seg_descriptor:                       
mov edx,eax
shl eax,16
or ax,bx                           ;描述符前32位(EAX)构造完毕

and edx,0xffff0000                 ;清除基地址中无关的位
rol edx,8
bswap edx                          ;装配基址的31~24和23~16  (80486+)

xor bx,bx
or edx,ebx                         ;装配段界限的高4位

or edx,ecx                         ;装配属性

retf

;-----------------------------------------------------------
;构造一个门描述符（调用门等都行） 输入 eax 门代码所在的段内偏移地址 bx门代码所在段的段选择子 cx 段类型即属性 返回 edx:eax描述符
make_gate_descriptor:
push ebx
push ecx
mov edx,eax
and edx,0xffff0000;得到偏移地址的高16位
or dx,cx;将属性装入 edx 得到描述符的高32位(dx为0，所以edx的低16为是cx了)
and eax,0x000ffff;偏移地址低16位
shl ebx,16
or eax,ebx;组装段选择子
;即整体结构 高32位 31-16：偏移地址高16位 15-0:属性
;		   低32位 31-15：段选择子   15-0: 偏移地址低16位
pop ecx
pop ebx
retf

;-----------------------------------------------------------
sys_routine_end:
;===========================================================
;以下是内核数据段
SECTION core_data vstart=0
pgdt dw 0
dd 0
ram_alloc dd 0x00100000;下次分配内存的起始地址

;符号地址检索表(sign-address lookup table)
salt:
salt_1 db '@PrintString'
times 256-($-salt_1) db 0
dd put_string
dw sys_routine_seg_sel

salt_2 db '@ReadDiskData'
times 256-($-salt_2) db 0
dd read_hard_disk_0
dw sys_routine_seg_sel

salt_3 db '@PrintDwordAsHexString'
times 256-($-salt_3) db 0
dd put_hex_dword
dw sys_routine_seg_sel

salt_4 db '@TerminateProgram'
times 256-($-salt_4) db 0
dd return_point
dw core_code_seg_sel

salt_item_len equ $-salt_4 ;宏定义常数
salt_items equ ($-salt)/salt_item_len

message_1 db  '  If you seen this message,that means we '
db  'are now in protect mode,and the system '
db  'core is loaded,and the video display '
db  'routine works perfectly.',0x0d,0x0a,0

message_2 db  '  System wide CALL-GATE mounted.',0x0d,0x0a,0

message_3 db  0x0d,0x0a,'  Loading user program...',0

do_status db  'Done.',0x0d,0x0a,0

message_6 db  0x0d,0x0a,0x0d,0x0a,0x0d,0x0a
db  '  User program terminated,control returned.',0

bin_hex db '0123456789ABCDEF'
;put_hex_dword子过程用的查找表 

core_buf times 2048 db 0;内核缓冲区，用于加载程序时暂时保存第一个扇区

esp_pointer dd 0 ;内核用来临时保存自己的栈指针，因为切换到用户程序
;时要切换到用户程序的栈，而切换来又要恢复，所以用这个空间保存栈指针

cpu_brnd0        db 0x0d,0x0a,'  ',0
cpu_brand  times 52 db 0
cpu_brnd1        db 0x0d,0x0a,0x0d,0x0a,0

;任务控制块链
tcb_chain dd 0

core_data_end:

;===========================================================
;以下是内核代码段
SECTION core_code align=16 vstart=0

;-----------------------------------------------------------
;ldt里安装新的描述符 输入 edx:eax描述符 ebx为tcb基地址 
;输出 cx描述符选择子
fill_descriptor_in_ldt:
push eax
push edx
push edi
push ds

mov ecx,mem_0_4_gb_seg_sel
mov ds,ecx

mov edi,[ebx+0x0c];获得ldt基地址
xor ecx,ecx
mov cx,[ebx+0x0a];获得LDT界限
inc cx;ldt总长度

mov [edi+ecx+0x00],eax
mov [edi+ecx+0x04],edx;安装描述符

add cx,8
dec cx;新界限

mov [ebx+0x0a],cx; 更新界限

mov ax,cx
xor dx,dx
mov cx,8
div cx

mov cx,ax
shl cx,3
or cx,0000_0000_0000_0100B;使TI位1 指向LDT 最后使RPL=00

pop ds
pop edi
pop edx
pop eax
ret

;-----------------------------------------------------------
;加载并重定位用户程序 输入 push逻辑扇区号 push 任务控制块基地址
;输出 无
load_relocate_program:
pushad;push8个通用寄存器
push ds
push es

mov ebp,esp;为访问堆栈参数做准备（esp/sp不能直接访问）

mov ecx,mem_0_4_gb_seg_sel
mov es,ecx

mov esi,[ebp+11*4];取得传入参数 tcb基地址

;以下申请创建LDT所需的内存
mov ecx,160 ;允许安装20个描述符的空间
call sys_routine_seg_sel:allocate_memory
mov [es:esi+0x0c],ecx ;登记LDT基地址到TCB中
mov word [es:esi+0x0a],0xffff;登记LDT初始界限到TCB中

;以下开始加载用户程序
mov eax,core_data_seg_sel
mov ds,eax

;读用户程序第一个扇区到缓存区
mov eax,[ebp+12*4];从堆栈取得传入参数 起始逻辑扇区号
mov ebx,core_buf
call sys_routine_seg_sel:read_hard_disk_0

;以下判断整个程序有多大
mov eax,[core_buf];程序大小
mov ebx,eax
and ebx,0xfffffe00 
add ebx,512 ;给eax的备份ebx 512字节对齐了
test eax,0x000001ff;看eax是不是512字节对齐
cmovnz eax,ebx ;不是就用对齐后的ebx

mov ecx,eax
call sys_routine_seg_sel:allocate_memory
mov [es:esi+0x06],ecx ;将程序加载的基地址写入TCB

mov ebx,ecx;eax是总大小 ebx是地址
xor edx,edx
mov ecx,512
div ecx
mov ecx,eax ;eax是总扇区数

mov eax,mem_0_4_gb_seg_sel
mov ds,eax

mov eax,[ebp+12*4];起始扇区号
.b1:
call sys_routine_seg_sel:read_hard_disk_0
inc eax;ebx不用变，read_hard_disk_0会自动+512
loop .b1 

mov edi,[es:esi+0x06];从TCB读用户程序基地址

;建立用户程序header段描述符
mov eax,edi
mov ebx,[edi+0x04];段长度
dec ebx;段界限
mov ecx,0x0040f200 ;字节粒度 数据段 特权级3
call sys_routine_seg_sel:make_seg_descriptor

;安装描述符到LDT
mov ebx,esi  ;esi为tcb基地址
call fill_descriptor_in_ldt

or cx,0000_0000_0000_0011B;设置选择子特权级为3
mov [es:esi+0x44],cx ;将用户程序header段选择子写道TCB
mov [edi+0x04],cx ;也写道程序头部

;程序代码段描述符
mov eax,edi
add eax,[edi+0x14];代码起始线性地址
mov ebx,[edi+0x18];代码段长度
dec ebx ;段界限
mov ecx,0x0040f800 ;字节粒度 代码段 特权级3
call sys_routine_seg_sel:make_seg_descriptor
mov ebx,esi;TCB基地址
call fill_descriptor_in_ldt
or cx,0000_0000_0000_0011b ;设置选择子的特权级为3
mov [edi+0x14],cx;登记代码段选择子到头部

;数据段
mov eax,edi
add eax,[edi+0x1c];数据段线性地址
mov ebx,[edi+0x20];段长度
dec ebx
mov ecx,0x0040f200 ;字节粒度 数据段 特权级3
call sys_routine_seg_sel:make_seg_descriptor
mov ebx,esi;tcb 基地址
call fill_descriptor_in_ldt
or cx,0000_0000_0000_0011b ;设置选择子特权级3
mov [edi+0x1c],cx;数据段选择子写回头部

;栈段
mov ecx,[edi+0x0c];栈段大小，4KB粒度
mov ebx,0x000fffff
sub ebx,ecx ;真正的段界限由0x000fffff-x得到
mov eax,4096
mul ecx
mov ecx,eax ;申请分配的带下
call sys_routine_seg_sel:allocate_memory
add eax,ecx; 堆栈 高端 的物理地址（eax是大小 ecx是起始地址）
mov ecx,0x00c0f600;4KB粒度，向下扩展数据段 特权级3
call sys_routine_seg_sel:make_seg_descriptor
mov ebx,esi ;TCB基地址
call fill_descriptor_in_ldt
or cx,0000_0000_0000_0011b;特权级3
mov [edi+0x08],cx;写回头部

;以下重定位salt
mov eax,mem_0_4_gb_seg_sel
mov es,eax;和上一章不同，这里时程序的头部段描述符已经安装了，但是
;还没生效，所以没有通过程序header段描述符访问，而是用的4gb数据段

mov eax,core_data_seg_sel
mov ds,eax

cld
mov ecx,[es:edi+0x24];u-salt条目数 外循环次数
add edi,0x28;将edi由程序的起始有效地址（相对于4gb数据段基地址）指向u-salt的起始有效地址

.b2:
push ecx
push edi
mov ecx,salt_items;内循环次数
mov esi,salt
.b3:
push edi
push esi
push ecx;将三个寄存器保存起来，重复使用

mov ecx,64
repe cmpsd;比较256字节 64*4
jnz .b4
mov eax,[esi]
mov [es:edi-256],eax ;将找到的例程在段中的偏移地址写入u-salt
;对应项的字符串里
mov ax,[esi+4];选择子
or ax,00000000_0000_0011b ;以用户程序自己的特权级使用调用门
mov [es:edi-252],ax;回填调用门选择子

.b4:
pop ecx
pop esi
add esi,salt_item_len
pop edi
loop .b3;小循环

pop edi
add edi,256
pop ecx
loop .b2;大循环

mov esi,[ebp+11*4];从堆栈取得TCB基地址

;创建0特权级堆栈
mov ecx,4096
mov eax,ecx
mov [es:esi+0x1a],ecx
shr dword [es:esi+0x1a],12
call sys_routine_seg_sel:allocate_memory
add eax,ecx;使用高端地址作为基地址（因为分配的地址是较低的那一侧，+长
;度，即使高端地址，用高端地址是因为堆栈向下扩展）
mov [es:esi+0x1e],eax
mov ebx,0xffffe;段界限
mov ecx,0x00c09600 ;4kb粒度 向下扩展 特权级0
call sys_routine_seg_sel:make_seg_descriptor
mov ebx,esi
call fill_descriptor_in_ldt
;or cx,00000000_00000000;设置选择子特权级为0（原本就为0）
mov [es:esi+0x22],cx;登记0特权级堆栈选择子到TCB
mov dword [es:esi+0x24],0;登记0特权级堆栈初始esp到TCB

;创建1特权级堆栈
mov ecx,4096
mov eax,ecx
mov [es:esi+0x28],ecx
shr [es:esi+0x28],12
call sys_routine_seg_sel:allocate_memory
add eax,ecx
mov [es:esi+0x2c],eax
mov ebx,0xffffe;段界限
mov ecx,0x00c0b600 ;4kb粒度 向下扩展数据段 特权级1
call sys_routine_seg_sel:make_seg_descriptor
mov ebx,esi ;tcb基地址
call fill_descriptor_in_ldt
or cx,0000_0000_0000_0001b;设置选择子特权级1
mov [es:esi+0x30],cx
mov dword [es:esi+0x32],0

;创建2特权级堆栈
mov ecx,4096
mov eax,ecx
mov [es:esi+0x36],ecx
shr [es:esi+0x36],12
call sys_routine_seg_sel:allocate_memory
add eax,ecx
mov [es:esi+0x3a],ecx
mov ebx,0xffffe
mov ecx,0x00c0d600
call sys_routine_seg_sel:make_seg_descriptor
mov ebx,esi
call fill_descriptor_in_ldt
or cx,0000_0000_0000_0010;特权级2
mov [es:esi+0x3e],cx;特权级2选择子登记到tcb
mov dword [es:esi+0x40],0;初始化esp登记到tcb

;以下在GDT中登记ldt描述符
mov eax,[es:esi+0x0c];ldt起始线性地址
movzx ebx,word [es:esi+0x0a];段界限movzx mov with zero extionsion
mov ecx,0x00408200 ;数据段 特权级0
call sys_routine_seg_sel:make_seg_descriptor
call sys_routine_seg_sel:set_up_gdt_descriptor
mov [es:esi+0x10],cx;登记ldt选择子到tcb中

;创建用户程序tss
mov ecx,104;tss的基本大小
mov [es:esi+0x12],cx
dec word [es:esi+0x12];登记tss界限到tcb
call sys_routine_seg_sel:allocate_memory
mov [es:esi+0x14],ecx ;登记tss基地址到tcb

;登记tss表格内容
mov word [es:ecx+0],0 ;反向链 = 0

mov edx,[es:esi+0x24];获得特权级0的初始堆栈esp
mov [es:ecx+4],edx ;登记到tss

mov dx,[es:esi+0x22] ;获得特权级0的堆栈段选择子
mov [es:ecx+8],dx

mov edx,[es:esi+0x32];获得特权级1堆栈初始esp
mov [es:ecx+12],edx

mov dx,[es:esi+0x30];获得特权级1堆栈段选择子
mov [es:ecx+16],dx

mov edx,[es:esi+0x40];获得特权级2堆栈初始esp
mov [es:ecx+20],edx

mov dx,[es:esi+0x3e] ;获得特权级2堆栈段选择子
mov [es:ecx+24],dx

mov dx,[es:esi+0x10];获取ldt在gdt里的选择子
mov [es:ecx+96],dx

mov dx,[es:esi+0x12];获得i/o位图偏移
mov [es:ecx+102],dx

mov word [es:ecx+100],0 ;T=0

;以下在GDT里登记tss描述符
mov eax,[es:esi+0x14] ;tss的起始线性地址
movzx ebx,word [es:esi+0x12];段界限
mov ecx,0x00408900 ;tss描述符 数据段 特权级 0 
call sys_routine_seg_sel:make_seg_descriptor
call sys_routine_seg_sel:set_up_gdt_descriptor
mov [es:esi+0x18],cx;登记tss在gdt里的选择子到tcb

pop es
pop ds
popad

ret 8;ret 8 是先pop eip 再丢弃调用前压入的两个参数（也就是丢弃8字节）

;-----------------------------------------------------------
;在TCB链上追加任务控制块
;参数 ecx 即 tcb线性基地址
append_to_tcb_link:
push eax
push edx
push ds;对于段寄存器 push进去的确实是段选择子，不过处理器还是push了4字节
push es

mov eax,core_data_seg_sel
mov ds,eax
mov eax,mem_0_4_gb_seg_sel
mov es,eax

mov dword [es:ecx+0x00],0;当前tcb指针域清零，表示这是最后一个tcb

mov eax,[tcb_chain];tcb表头指针
or eax,eax ;链表为空？
jz .notcb

.searc:
mov edx,eax
mov eax,[es:edx+0x00]
or eax,eax
jnz .searc

mov [es:edx+0x00],ecx
jmp .retpc

.notcb:
mov [tcb_chain],ecx ;如果为空表，直接令表头指针指向tcb

.retpc:
pop es
pop ds
pop edx
pop eax
ret

;-----------------------------------------------------------
;内核入口
start:
mov ecx,core_data_seg_sel
mov ds,ecx

mov ebx,message_1
call sys_routine_seg_sel:put_string

;显示处理器品牌信息 
mov eax,0x80000002
cpuid
mov [cpu_brand + 0x00],eax
mov [cpu_brand + 0x04],ebx
mov [cpu_brand + 0x08],ecx
mov [cpu_brand + 0x0c],edx

mov eax,0x80000003
cpuid
mov [cpu_brand + 0x10],eax
mov [cpu_brand + 0x14],ebx
mov [cpu_brand + 0x18],ecx
mov [cpu_brand + 0x1c],edx

mov eax,0x80000004
cpuid
mov [cpu_brand + 0x20],eax
mov [cpu_brand + 0x24],ebx
mov [cpu_brand + 0x28],ecx
mov [cpu_brand + 0x2c],edx

mov ebx,cpu_brnd0                  ;显示处理器品牌信息 
call sys_routine_seg_sel:put_string
mov ebx,cpu_brand
call sys_routine_seg_sel:put_string
mov ebx,cpu_brnd1
call sys_routine_seg_sel:put_string

;以下开始安装为整个系统服务的调用门。特权级之间的控制转移必须
;使用门
mov edi,salt;c_salt的起始位置
mov ecx,salt_items;c_salt的条目数量

.b3:
push ecx;保存循环次数
mov eax,[edi+256];该条目的32为偏移地址
mov bx,[edi+260];该条目的段选择子
mov cx,1_11_0_1100_000_00000b ;特权级3的调用门（0 1 2 3都允许访问）
;0个参数 （因为用寄存器传参，没用栈）

call sys_routine_seg_sel:make_gate_descriptor
call sys_routine_seg_sel:set_up_gdt_descriptor
mov [edi+260],cx ;将返回的门描述符选择子回填
add edi,salt_item_len ;指向下一个c-salt
pop ecx;恢复循环次数
loop .b3

;对门进行测试
mov ebx,message_2
call far [salt_1+256]

mov ebx,message_3
call sys_routine_seg_sel:put_string;在内核中调用不需要通过门也可以

;创建任务控制块
mov ecx,0x46
call sys_routine_seg_sel:allocate_memory
call append_to_tcb_link ;将任务控制块追加到tcb链表

push dword 50
push ecx
call load_relocate_program

mov ebx,do_status
call sys_routine_seg_sel:put_string

mov eax,mem_0_4_gb_seg_sel
mov ds,eax

ltr [ecx+0x18];加载任务状态段
lldt [ecx+0x10];加载ldt

mov eax,[ecx+0x44]
mov ds,eax;切换到用户程序头部段

;以下假装是从调用门返回。模仿处理器压入返回参数
push dword [0x08];调用前的堆栈选择子
push dword 0 ;调用前的esp

push dword [0x14];调用前的代码段选择子
push dword [0x10];调用前的eip
retf;通过这个跳转到用户程序

;-----------------------------------------------------------
;应用程序返回点
return_point:
mov eax,core_data_seg_sel
mov ds,eax

mov ebx,message_6
call sys_routine_seg_sel:put_string
hlt
core_code_end:
;==========================================================
SECTION core_trail
;----------------------------------------------------------
core_end:
```

​	以上代码编译通过，运行正确（内核引导程序和用户程序仍是上一章的）