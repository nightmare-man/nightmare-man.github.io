---
layout: post
title: 汇编语言笔记11标志寄存器
subtitle: 汇编语言笔记11标志寄存器
date: 2020-06-4
author: nightmare-man
tags: 8086汇编
---

# 汇编语言笔记11标志寄存器

### 0x00 标志寄存器简介

​		标志寄存器是cpu内部的一种特殊的寄存器，有以下三种作用：

​	（1）用来储存相关指令的某些执行结果

​	（2）用来为cpu执行相关指令提供行为依据

​	（3）用来控制cpu的相关工作方式

​		8086中的标志寄存器有16位，其中储存的信息被称为程序状态字（Program Status Word）PSW,又称为PSW寄存器 flag寄存器

​		flag和其他寄存器不同，其他寄存器用来储存数据，而flag是按位起作用，每一位都有专门的含义，记录特定的信息		![QQ截图20200604161957](/assets/img/QQ截图20200604161957.png)



### 0x01 各标志含义

#### 		ZF标志

​		flag的第6位是ZF ，零标志位，它记录相关指令（一般是刚被执行的指令）执行后，其结果是否位0.如果结果为0，那ZF=1 如果不为0,ZF =0,例如

​		mov ax,1	sub ax,1     执行后结果为0，则 ZF=1

​		mov ax,2 	sub ax,1    执行后结果不为0，则ZF=0

​		**注意**  在8086cpu的指令集中，有的指令的执行是影响标志寄存器的，比如add，sub，mul，div，inc，or，and等，大多是运算指令（逻辑或者算数运算）；

​		而有的指令对标志寄存器没有影响，比如，**mov，push，pop等 大多是传送指令**

#### 		PF标志

​		flag的第2位是PF，奇偶标志位，记录相关指令执行后，结果的所有bit位中1的个数是否位偶数（偶数包含0），如果为偶数，PF=1否则为0，例如

​		mov al,1	add al,10	执行后结果为11也就是0000 1011b，有3个1，PF=0

​		mov al,1	or al,2	执行后为0000 0011b 有2个1，偶数PF=1

#### 		SF标志

​		flag的第7位是SF，符号标志位，记录相关指令执行后，其结果是否为负。如果结果为负，SF=1否则为0。**值得注意的是** **这里是把数据当作有符号数来看待，看其运算结果作为有符号数是否为负数，因为无符号数不存在负数**

​		0000 0001b 可以看作无符号数1，或有符号数+1    1000 0001b 可以看作无符号数129 也可以看作有符号数 -127 （补码表示 127是 0111 1111b 取反 1000 0000  再加1 -》1000 0001b）

​		不管我们如何看待 cpu执行add等指令时，就已经包含了两种含义，关键在于我们的程序需要哪一种结果，当我们将数据当作无符号数看待时，那么SF的值将没有意义，虽然相关指令影响了他的值

​		mov al,10000001b	add al,1 执行后al 1000 0010b  SF=1 表示 如果是有符号数的运算，那么结果为负

![QQ截图20200604164133](/assets/img/QQ截图20200604164133.png)

​		sub al，al 	->	al=0	那么ZF=1 PF=1 SF=0  (注意0个1也是偶数个 PF=1)

​		mov al,1	->	al=1	ZF=1	PF=1	SF=0 (**mov指令不影响标志寄存器的任何标志位**)

​		push	ax	->	ax=1	ZF=1	PF=1	SF=0(**push mov pop指令不影响标志寄存器的任何标志位**)

​		pop bx	->	bx=1	ZF=1	PF=1	SF=0(**push mov pop指令不影响标志寄存器的任何标志位**)

​		add al,bl	->	al=2	ZF=0	PF=0	SF=0

​		add al,10	->	al=12 ZF=0	PF=1 (0000 1100b)	SF=0

​		mul al	->	al=无符号144 有符号 -112	ZF=0	PF=1 (1001 0000b)	SF=1



#### 		CF标志

​		flag的第0位是CF，进位标志位，一般情况下，在进行**无符号数**运算时，它记录了运算结果的**最高有效位向更高位的进位值，或者从更高位的借位值**

​		为什么说是无符号数的时候？ 不论我们将数据看作有符号数还是无符号数，cpu不管，cpu在设置CF标志时，将其看作无符号位一旦发生进位或者借位就置1

​		mov al,98h	add al,al	执行后 (al)=30h,CF=1,CF记录了从最高有效位向更高位的进位值1

​		add al,al	执行后（al）=60h  	CF=0 没发生进位和借位

​		mov al,79h	sub al,98h	执行后，al=ffh 发生借位 CF =1

​		

#### 		OF标志位

​		溢出问题（针对**有符号数**），8位寄存器或内存单元所能表示的有符号数范围时-128-127，16位是-32768-32767，如果运算结果超出了机器所能表达的范围，将产生溢出

​		mov al,98	add al,99	执行后al=197（无符号数）-59（有符号数） 超过了127变负数了 OF=1

​		mov al,0f0h	add al,088h	执行后al=78h （120 无符号数 有符号数都是） -16+-120=-136 超过了-128因而变成正数了，所以OF=1

![QQ截图20200604170732](/assets/img/QQ截图20200604170732.png)

![QQ截图20200604170759](/assets/img/QQ截图20200604170759.png)

​		sub al,al	al=0	CF=0(无进位)	OF=0(无溢出)	SF=0（无负数）	ZF=1	PF=1(0个1)

​		mov al,10h	al=10h	CF=0	OF=0	SF=0	ZF=0	PF=1	mov指令不影响标志寄存器

​		add al,90h	al=0a0h 	CF=0 OF=1(溢出了 有符号数下 变负数-96)	SF=1 (负数了)	ZF=0	PF=0(三个1)

​		mov al,80h	al=80h	CF=0	OF=1	SF=1	OF=O	PF=0

​		add al,80h	al=0h	CF=1	OF=1(-128+-128溢出了)	SF=0(不是负数)	ZF=1	PF=1	