---
layout: post
title: 从实模式到保护模式笔记11任务切换
subtitle: 从实模式到保护模式笔记11任务切换
date: 2020-07-16
author: nightmare-man
tags: x86汇编
---
# 从实模式到保护模式笔记11任务切换

### 0x00 代码

    本章代码基于上一章代码，因此不再全部展现，只列出各段中不同（如果没有不同，对应段将不展示）

```nasm

;====================================================

SECTION sys_routine vstart=0
terminate_current_task:;终止当前任务的运行
;此例程由当前任务调用，算当前任务的一部分（全局空间）
pushfd;以32位模式压当前EFLAGES入栈（不论是16位还是32位模式下）
;该指令由编译器提供
mov edx,[esp]
add esp,4;这三条指令 等价于pushfd pop edx
;这么写只是为了展示32位中可以用[esp]
mov eax,core_data_seg_sel
mov ds,eax

test dx,0100_0000_0000_0000B ;看NT位是否为1
jnz .b1;为1则是嵌套任务，返回前一级任务（会自动从TSS里找到前一级任
;务TSS的选择子）
mov ebx,core_msg1;当前任务不嵌套，没有前一级，用jmp返回切换到
;任务管理器任务
call sys_routine_seg_sel:put_string
jmp far [prgman_tss];任务管理程序任务

.b1:
mov ebx,core_msg0
call sys_routine_seg_sel:put_string
iretd
    ...
sys_routine_end:
;===================================================
SECTION core_data vstart=0

    ...
 ;程序管理器的任务信息 
prgman_tss dd  0             ;程序管理器的TSS基地址
dw  0             ;程序管理器的TSS描述符选择子 

prgman_msg1 db  0x0d,0x0a
db  '[PROGRAM MANAGER]: Hello! I am Program Manager,'
db  'run at CPL=0.Now,create user task and switch '
db  'to it by the CALL instruction...',0x0d,0x0a,0
                 
prgman_msg2 db  0x0d,0x0a
db  '[PROGRAM MANAGER]: I am glad to regain control.'
db  'Now,create another user task and switch to '
db  'it by the JMP instruction...',0x0d,0x0a,0
                 
prgman_msg3 db  0x0d,0x0a
db  '[PROGRAM MANAGER]: I am gain control again,'
db  'HALT...',0

core_msg0 db  0x0d,0x0a
db  '[SYSTEM CORE]: Uh...This task initiated with '
db  'CALL instruction or an exeception/ interrupt,'
db  'should use IRETD instruction to switch back...'
db  0x0d,0x0a,0

core_msg1 db  0x0d,0x0a
db  '[SYSTEM CORE]: Uh...This task initiated with '
db  'JMP instruction,  should switch to Program '
db  'Manager directly by the JMP instruction...'
db  0x0d,0x0a,0
    ...
core_data_end:
;====================================================
SECTION core_code vstart=0
    ...
load_relocate_program:;加载并重定位用户程序
    ...
;创建用户程序的TSS
mov ecx,104                        ;tss的基本尺寸
mov [es:esi+0x12],cx              
dec word [es:esi+0x12]             ;登记TSS界限值到TCB 
call sys_routine_seg_sel:allocate_memory
mov [es:esi+0x14],ecx              ;登记TSS基地址到TCB

;登记基本的TSS表格内容
mov word [es:ecx+0],0              ;反向链=0

mov edx,[es:esi+0x24]              ;登记0特权级堆栈初始ESP
mov [es:ecx+4],edx                 ;到TSS中

mov dx,[es:esi+0x22]               ;登记0特权级堆栈段选择子
mov [es:ecx+8],dx                  ;到TSS中

mov edx,[es:esi+0x32]              ;登记1特权级堆栈初始ESP
mov [es:ecx+12],edx                ;到TSS中

mov dx,[es:esi+0x30]               ;登记1特权级堆栈段选择子
mov [es:ecx+16],dx                 ;到TSS中

mov edx,[es:esi+0x40]              ;登记2特权级堆栈初始ESP
mov [es:ecx+20],edx                ;到TSS中

mov dx,[es:esi+0x3e]               ;登记2特权级堆栈段选择子
mov [es:ecx+24],dx                 ;到TSS中

mov dx,[es:esi+0x10]               ;登记任务的LDT选择子
mov [es:ecx+96],dx                 ;到TSS中

mov dx,[es:esi+0x12]               ;登记任务的I/O位图偏移
mov [es:ecx+102],dx                ;到TSS中 

mov word [es:ecx+100],0            ;T=0

mov dword [es:ecx+28],0            ;登记CR3(PDBR)

;访问用户程序头部，获取数据填充TSS 
mov ebx,[ebp+11*4]                 ;从堆栈中取得TCB的基地址
mov edi,[es:ebx+0x06]              ;用户程序加载的基地址 

mov edx,[es:edi+0x10]              ;登记程序入口点（EIP） 
mov [es:ecx+32],edx                ;到TSS

mov dx,[es:edi+0x14]               ;登记程序代码段（CS）选择子
mov [es:ecx+76],dx                 ;到TSS中

mov dx,[es:edi+0x08]               ;登记程序堆栈段（SS）选择子
mov [es:ecx+80],dx                 ;到TSS中

mov dx,[es:edi+0x04]               ;登记程序数据段（DS）选择子
mov word [es:ecx+84],dx            ;到TSS中。注意，它指向程序头部段

mov word [es:ecx+72],0             ;TSS中的ES=0

mov word [es:ecx+88],0             ;TSS中的FS=0

mov word [es:ecx+92],0             ;TSS中的GS=0

pushfd
pop edx
mov dword [es:ecx+36],edx          ;EFLAGS

;在GDT中登记TSS描述符
mov eax,[es:esi+0x14]              ;TSS的起始线性地址
movzx ebx,word [es:esi+0x12]       ;段长度（界限）
mov ecx,0x00408900                 ;TSS描述符，特权级0
call sys_routine_seg_sel:make_seg_descriptor
call sys_routine_seg_sel:set_up_gdt_descriptor
mov [es:esi+0x18],cx               ;登记TSS选择    子到TCB
    ...



start:

    ...
;为程序管理器的TSS分配内存空间（程序管理器即指当前的内核任务代码）
mov ecx,104
call sys_routine_seg_sel:allocate_memory
mov [prgman_tss+0x00],cx;保存程序管理器的TSS基地址
;设置prgmanTSS的必要项目
mov word [es:ecx+96],0;没有lDT
mov word [es:ecx+102],103;没有I/O位图（也就是IO操作只看CPL和IOPL的关系）
mov word [es:ecx+0],0;反向链（上一级任务TSS选择子）为0
mov dword [es:ecx+28],0;登记CR3
mov word [es:ecx+100],0;T=0,不开启调试
;不需要 0、1、2特权级堆栈设置

;创建TSS描述符 并安装到GDT
mov eax,ecx;tss起始线性地址
mov ebx,103;界限
mov ecx,0x00408900;TSS描述符 特权级0
call sys_routine_seg_sel:make_seg_descriptor
call sys_routine_seg_sek:set_up_gdt_descriptor
mov [prgman_tss+0x04],cx;保存prgman的tss选择子

;将TR寄存器指向当前任务的TSS，也就是prgman
ltr cx
;从此认为prgman在执行中
mov ebx,prgman_msg1
call sys_routine_seg_sel:put_string

mov ecx,0x46
call sys_routine_seg_sel:allocate_memory
call append_to_tcb_link;新建一个空的的TCB并加到tcb链中（现在看来tcb
;链并没有卵用，估计是为以后抢占式按时切换做准备)
;返回的ecx是tcb线性基地址，在load_relocate_program中使用

push dword 50
push ecx;tcb基地址

call load_relocate_program;加载任务,把任务第一次运行时的TSS设置好了
;方便切换
call far [es:ecx+0x14];切换任务 call发起的切换，要看特权级cpl和dpl
;不改变旧任务busy位（仍为1）（描述符中） 不改变其nt位 新任务busy置1 nt置1（
;表示有上一级任务/有嵌套) 会把TSS里的 0偏移指向旧任务的TSS选择子

;重新加载并切换任务
mov ebx,prgman_msg2
call sys_routine_seg_sel:put_string

mov ecx,0x46
call sys_routine_seg_sel:allocate_memory
call append_to_tcb_link;又新建一个空的tcb

push dowrd 50
push ecx

call load_relocate_program;重新加载的 是同一个程序的一个新的任务

jmp far [es:ecx+0x14];执行任务切换

mov ebx,program_msg3
call sys_routine_seg_sel:put_string
hlt

core_code_end:
```


