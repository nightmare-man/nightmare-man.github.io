---

layout: post
title: 同步与互斥问题分析
author: nightmare-man
subtitle: 同步与互斥问题分析
date: 2022-12-20
tags: 操作系统

---
# 0x00 并发的两个问题
	同步与互斥是并发的两个问题，本质是**执行流间的约束关系**。**互斥**是针对资源的访问而言，不能同时访问，是一种间接约束关系，表明不能同时执行某些代码。**同步**指多个执行流要按照一定顺序，是一种直接约束关系。
# 0x01 实现互斥的方法
	互斥有几个原则，空闲让进，忙则等待，有限等待，让权等待，说人话就是，能用就用，目前不能用就先不用，但是最终一定要能用到，我不能用的时候我去歇着让别人来（执行）。
	**锁**解决了前三条，谁用谁加锁，加锁后只能自己用，用完了把锁打开。因此，互斥的访问一个资源，就是尝试获得锁的过程。怎么获得锁呢？又有两种解决方案：**自旋锁**和**互斥锁**。前者类似while循环，循环里就一件事不断试图拿到锁，拿到就出循环，去访问资源，然后释放。后者则是试图获得锁，拿不到就阻塞，直到有人释放锁，再来试图拿，以此类推，第四条也解决了。
	自旋锁的好处是，减少了系统调用，坏处是可能长时间空loop；互斥锁则相反
# 0x02 实现同步
	以下是几种工具，解决不同场景的问题：
	①信号量，实现（可多个同时访问的）的互斥或者（特定的）前驱后继关系。主要原理，信号量可以设置初始，两个操作，wait和signal 又称p,v。p操作执行原子操作\{ 信号量--，判断减后是否小于0，如果小于0则加入阻塞队列 \} v操作执行原子操作\{信号量++，判断+后是否<=0,则从对应阻塞队列拿一个出来放在就绪队列并将锁给该执行流\}。
	用信号量解决前驱后继关系有个特点，就是一次p满足一个v，也就是如果想要让bcd三个执行流在a后执行，需要a调用三个v操作，而bcd各自调用一次p。
	②条件变量，实现前驱后继关系，需要和互斥锁一起用。主要原理，条件变量有两个操作，wait signal。前者执行原子操作\{等待条件，加入该条件变量的阻塞队列并释放互斥锁\}，后者执行原子操作\{ 使该条件变量的条件满足，从该条件变量的阻塞队列拿出一个执行流改为就绪 \}。你看完可能会疑惑,互斥锁在哪儿呢？实际上同一个条件变量的wait 和signal操作都被对应的互斥锁lock unlock包围。并且一般在wait的外层套一个while,只有条件满足才跳出。
```c
	//wait使用过程
	lock(&mutex);
	while(not_fit(condition) ){ //为什么这儿需要用循环而不是if，防止虚假唤醒：1wait有可能没被阻塞直接返回了，2防止signal唤醒了多个执行流，这些执行流又修改了condition
		wait(&condition,&mutex);//释放锁并阻塞 原子操作  
	}
	unlock(&mutex);
	//signal使用过程
	lock(&mutex);
	enable(&condition);
	signal(&condition,&mutex);//根据man pthread_cond_signal得到的信息，signal保证至少唤醒一个因wait阻塞的执行流,这是虚假唤醒的原因,有可能唤醒多个执行流，**但是只有一个拿着锁**，且释放锁后也不会给其他被唤醒的执行流，导致虚假唤醒。而broadcast则**依次唤醒阻塞的执行流，并让锁在这些执行流之间依次传递**，不会导致虚假唤醒。
	unlock(&mutex);
```
	为什么要用这么复杂的条件变量？首先考虑能不能直接用互斥锁解决前驱后继关系，当然可以，需要条件的地方，直接while(true)\{ 加锁;判断是否满足条件，满足就释放锁，并break；释放锁 \}  。满足条件的地方就 \{加锁；修改条件;释放锁\}。这种方法有个问题就是效率很低，不断执行加锁释放锁。